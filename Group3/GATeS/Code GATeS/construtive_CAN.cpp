#include "matriz.h"
#include "construtive_CAN.h"
#include "Gen.h"
#include <math.h>
#include <time.h>

int *sum_profit1=NULL;
int *reserve_rev = NULL;
int *reserve_cost = NULL;
int *conflicts = NULL;

int can1 = 1;
int original_prod_number=0;
int *Variance_vector = (int*)malloc(sizeof(int)*MAXC);
int** CvP_npp = generate_2D_matrix_int(MAXC, MAXPROD);
float *aux_vector = (float*)malloc(sizeof(float)*MAXC);
int **cost_matrix = NULL;
int **rev_matrix = NULL;
int t_prod = 0;

int compare2(const void * a, const void * b)
{
	return (sum_profit1[*(int*)b] + (reserve_rev[*(int*)b] - reserve_cost[*(int*)b])*0.2 - (sum_profit1[*(int*)a] + (reserve_rev[*(int*)a] - reserve_cost[*(int*)a])*0.2)); //(conflicts[*(int*)a]- (conflicts[*(int*)b]));

}
int compare_var(const void * a, const void * b)
{
	return (int)((aux_vector[*(int*)b]) - aux_vector[*(int*)a]);
}

int compare_cost(const void *a, const void *b)
{
	return (int)((cost_matrix[*(int*)a][t_prod]) - (cost_matrix[*(int*)b][t_prod]));
}

int compare_npp(const void *a, const void *b)
{
	return (int)((rev_matrix[*(int*)a][t_prod]) /(cost_matrix[*(int*)a][t_prod]) - (rev_matrix[*(int*)b][t_prod]) /(cost_matrix[*(int*)b][t_prod]));
}
bool check_values2(int **sol, int *solp, int *fcpo, int** cost, int **revenue, int *sum_cost, int *sum_revenue, int total_cost, int prod, int cli);

//Function that tries to create an offer set for a product, with focus on fiting tight budget constraints
//It starts by assigning offers in increasing order of cost until the product reaches the minimum offer set required
//After creating the minimum offer set, the function tries to perform swaps in order to make the offer set profitable
//The difference between this function and the heuristic_constructive function is that this function does not take the offer set of other products into consideration 
void heuristic_constructive_alter(int client, int prod, float hurdle,
	int **cost, int **revenue,
	int* mcpo, int* budgetpo, int* offer_set,
	List** sorted_npp, int target_prod)
{

	int client_index[MAXC];
	bool selected_offers[MAXC];

	int offer_sum = 0;
	int offer_cost = 0;
	List *aux_list;
	int i;
	for (i = 0; i < MAXC; i++)
	{
		selected_offers[i] = false;
	}
	for (i = 0; i < client; i++)
		client_index[i] = i;
	cost_matrix = cost;
	rev_matrix = revenue;
	t_prod = target_prod;
	qsort(client_index, client, sizeof(int), compare_cost);

	//Inser offers in crescent order of cost until the offer quota is met
	for (i = 0; i < client && offer_sum < mcpo[target_prod] && offer_cost <= budgetpo[target_prod]; i++)
	{
		offer_set[offer_sum] = client_index[i];
		offer_sum++;
		offer_cost += cost[client_index[i]][target_prod];
		selected_offers[client_index[i]] = true;
	}
	if (offer_cost <= budgetpo[target_prod] && offer_sum >= mcpo[target_prod])
		offer_set[i] = -1;
	else
	{
		offer_set[0] = -1;
		return;
	}
	qsort(offer_set, mcpo[target_prod], sizeof(int), compare_npp);
	//Perform offer swaps aiming profitability. Current offers are explored in increasing order of profit and new offers are explored in decreasing order of profit. Stops when the hurdle rate was met
	for(int tries=0;tries<5;tries++)
	for (i = 0; i < mcpo[target_prod]; i++)
	{
			if (selected_offers[offer_set[i]])
			for (aux_list = sorted_npp[target_prod]->prox; aux_list; aux_list = aux_list->prox)
			{
				if(revenue[offer_set[i]][target_prod] - cost[offer_set[i]][target_prod] < revenue[aux_list->inf][target_prod] - cost[aux_list->inf][target_prod] && !selected_offers[aux_list->inf])
				if (offer_cost - cost[offer_set[i]][target_prod] + cost[aux_list->inf][target_prod] <= budgetpo[target_prod])
				{
					selected_offers[offer_set[i]] = false;
					offer_cost += cost[aux_list->inf][target_prod] - cost[offer_set[i]][target_prod];
					offer_set[i] = aux_list->inf;
					selected_offers[aux_list->inf] = true;
					break;
				}
			}
	}
	for (aux_list = sorted_npp[target_prod]->prox; aux_list; aux_list = aux_list->prox)
	{
		if (0 < revenue[aux_list->inf][target_prod] - cost[aux_list->inf][target_prod] && !selected_offers[aux_list->inf])
			if (offer_cost  + cost[aux_list->inf][target_prod] <= budgetpo[target_prod])
			{
				//selected_offers[offer_set[i]] = false;
				offer_cost += cost[aux_list->inf][target_prod];
				offer_set[i] = aux_list->inf;
				selected_offers[aux_list->inf] = true;
			}
	}

}

//This function creates a vector containing the profit variance for each client taking into consideration the profit generated by offering each product to the client
//The vector is ordered in decreasing order of profit variance
int* create_variance_vector(int **cost, int **revenue, int client, int prod, int *solp)
{
	int i, j, n;
	float average, dist_sum;
	int *prod_vector = (int*)malloc(sizeof(int)*prod);
	for (j = 0, n=0; j < prod; j++)
	{
		if (solp[j])
		{
			prod_vector[n] = j;
			n++;
		}
	}
	prod_vector[n] = -1;
	for (i = 0; i < client; i++)
	{
		aux_vector[i] = 0;
		Variance_vector[i] = i;
		for (j = 0; prod_vector[j] >= 0 && j<prod; j++)
		{
			aux_vector[i] += revenue[i][prod_vector[j]] / cost[i][prod_vector[j]];
		}
		average = 1.00*aux_vector[i] / n;
		for (j = 0, dist_sum=0; j< client; j++)
		{
			dist_sum += pow(average - aux_vector[j], 2);
		}
		aux_vector[i] = (dist_sum / n);
	}

	qsort((void*)Variance_vector, client, sizeof(int), compare_var);
	printf("\n");
	free(prod_vector);
	return Variance_vector;

}

//This function creates an matrix containing the list of clients for each product in decreasing order of NPP (profit per monetary unity invested)
int** create_cvp_npp_matrix(int** cost, int** revenue, int prod, int client)
{
	int  i, j;
	float npp;

	for(i = 0; i < client; i++)
	{
		for (j = 0; j < prod; j++)
		{
			CvP_npp[i][j] = j;
			aux_vector[j] =(float)(revenue[i][j]/cost[i][j]);
		}
		qsort((void*)CvP_npp[i], prod, sizeof(int), compare_var);
	}

	return CvP_npp;
}
//This function tries to solve offer conflicts between a set of validade offer sets and a product with an offer set yet to be validated
//A conflict happens when an offer of the new offer set would violate the maximum offer number constraint for a given client, if paired with the current validated offer sets
//The attempt of resolving conflicts consists on fiding a valid offer to replace each offer being evaluated that causes conflict. The algorithm tries to pick the swap that would cause the lesser loss of profit. 
bool resolve_conflicts(int **conflict_matrix, int **solc, int *solp, int conflicted_prod, int prod, int client, int **cost, int **revenue, int *fcostpo, int *maxofer, int *mcpo, int *budgetpo, List **sorted_npp, int *sum_offer_c, int *sum_offer_p, int* sum_offer_r, int **offer_reserve, int *reserve_cost, int* prod_cost, int *prod_rev, int *residual_budget, int *conflicts)
{
	
	int i, j, offer_count, block_impact, less_impacted_product, replacement;
	bool aux_solc[MAXC][MAXPROD];
	int *aux_prod_cost = (int*)malloc(sizeof(int)*prod);
	int *aux_prod_rev = (int*)malloc(sizeof(int)*prod);
	int *aux_residual_budget = (int*)malloc(sizeof(int)*prod);
	int *aux_sum_offer_p = (int*)malloc(sizeof(int)*prod);
	int *aux_sum_offer_c = (int*)malloc(sizeof(int)*client);
	int **aux_offer_reserve = (int**)malloc(sizeof(int*)*prod);
	int *prod_buffer = (int*)malloc(sizeof(int)*prod);
	List *c;
	FILE *log = fopen("Log_conflicts.txt", "a+");
	fprintf(log, "-------------------------------Conflicted prod %d --------------------------------\n", conflicted_prod);

	int sumoffers[MAXC];
	for (i = 0; i < client; i++)
	{
		aux_sum_offer_c[i] = sum_offer_c[i];
		for (j = 0; j < prod; j++)
		{
			if (solc[i][j] > 0)
			{
				aux_solc[i][j] = true;
			}
			else
				aux_solc[i][j] = false;
		}
	}
	for (j = 0; j < prod; j++)
	{
		aux_prod_cost[j] = prod_cost[j];
		aux_residual_budget[j] = residual_budget[j];
		fprintf(log, "Product %d original budget is %d\n", i, residual_budget[j]);
		aux_prod_rev[j] = prod_rev[j];
		aux_sum_offer_p[j] = sum_offer_p[j];
		if (solp[j]>0 || j==conflicted_prod)
		{
			aux_offer_reserve[j] = (int*)malloc(sizeof(int)*client);
			for (i = 0; i < client*0.7; i++)
				aux_offer_reserve[j][i] = offer_reserve[i][j];
		}
	}
	//For each client in decreasing order of profit for the conflicted product
	for (c = sorted_npp[conflicted_prod]->prox; c; c = c->prox)
	{
		//If the conflicted product is offered to the client
		if (aux_solc[c->inf][conflicted_prod])
		{
			aux_sum_offer_c[c->inf]++;
			//If the amount of offers in aux_sum_ffer_c exceeds the maximum offer restraint for the conflicted product
			if (aux_sum_offer_c[c->inf] > maxofer[c->inf])
			{
				for (offer_count = 0, j = 0, i = 0; j < prod; j++)
				{
					if (aux_solc[c->inf][j] && solp[j]>0)
					{
						offer_count++;
						prod_buffer[i] = j;
						i++;
					}
				}
				if (i < prod)
				{
					prod_buffer[i] = conflicted_prod;
				}
				if (i + 1 < prod)
				{
					prod_buffer[i + 1] = -1;
				}
				replacement = -1;

				fprintf(log, "Conflicted client %d\n", c->inf);
				//Explores other products in search of a product that can receive the exceding clients offer
				//Keeps track of the swap that will minimise profit loss
				for (j = 0, less_impacted_product = -1, block_impact = INT_MAX; j < prod && prod_buffer[j] >= 0; j++)
				{
					
					if (sum_offer_r[prod_buffer[j]] > 0)
					{
						for (i = 0; i < 0.7*client && aux_offer_reserve[prod_buffer[j]][i] != -1; i++)
						{
							if (aux_sum_offer_c[aux_offer_reserve[prod_buffer[j]][i]] + 1 > maxofer[aux_offer_reserve[prod_buffer[j]][i]])
							{
								aux_offer_reserve[prod_buffer[j]][i] = -2;
								continue;
							}
							if (aux_offer_reserve[prod_buffer[j]][i] == -2)
								continue;
							if (aux_residual_budget[prod_buffer[j]] - cost[aux_offer_reserve[prod_buffer[j]][i]][prod_buffer[j]] >= 0 && revenue[c->inf][prod_buffer[j]] - cost[c->inf][prod_buffer[j]] - (revenue[aux_offer_reserve[prod_buffer[j]][i]][prod_buffer[j]] - cost[aux_offer_reserve[prod_buffer[j]][i]][prod_buffer[j]]) < block_impact)
							{
								block_impact = revenue[c->inf][prod_buffer[j]] - cost[c->inf][prod_buffer[j]] -(revenue[aux_offer_reserve[prod_buffer[j]][i]][prod_buffer[j]] -cost[aux_offer_reserve[prod_buffer[j]][i]][prod_buffer[j]]);
								less_impacted_product = prod_buffer[j];
								replacement = i;
								break;
							}
						}
					}
					//If the offer removal would make the conflicted product to not meet its offer quota, marks the conflict as unsolvable
					if (aux_sum_offer_p[prod_buffer[j]] > mcpo[prod_buffer[j]] )
					 {
						 if ((revenue[c->inf][prod_buffer[j]] - cost[c->inf][prod_buffer[j]]) < block_impact)
						 {
							 block_impact = revenue[c->inf][prod_buffer[j]] - cost[c->inf][prod_buffer[j]];
							 less_impacted_product = prod_buffer[j];
							 if (replacement >= 0)
								 replacement = -1;
						 }
					 }
				}

				//Unsolvable conflict. 
				if (less_impacted_product == -1)
				{
					
					fprintf(log, "Conflict impossible to solve, closing process...\n");
					residual_budget[conflicted_prod] = budgetpo[conflicted_prod];
					sum_offer_p[conflicted_prod] = 0;
					prod_rev[conflicted_prod] = 0;
					prod_cost[conflicted_prod] = 0;
					free(prod_buffer);
					free(aux_prod_cost);
					free(aux_prod_rev);
					free(aux_residual_budget);
					free(aux_sum_offer_p);
					free(aux_sum_offer_c);
					free(aux_offer_reserve);
					fclose(log);
					return false;
				}
				else
				{
					//If a swap was found, performs the swap.
					if (replacement >= 0)
					{
						aux_solc[aux_offer_reserve[less_impacted_product][replacement]][less_impacted_product] = true;
						aux_solc[c->inf][less_impacted_product] = false;
						aux_prod_cost[less_impacted_product] += cost[aux_offer_reserve[less_impacted_product][replacement]][less_impacted_product] - cost[c->inf][less_impacted_product];
						aux_prod_rev[less_impacted_product] += revenue[aux_offer_reserve[less_impacted_product][replacement]][less_impacted_product] - revenue[c->inf][less_impacted_product];
						aux_residual_budget[less_impacted_product] += cost[c->inf][less_impacted_product] - cost[aux_offer_reserve[less_impacted_product][replacement]][less_impacted_product];
						fprintf(log, "Less affected product is %d with the new budget of %d and (%d,%d) offers. Replacement needed.\n Cost of the conflicted client  : %d Cost of the replacement (%d): %d\n", less_impacted_product, aux_residual_budget[less_impacted_product], aux_sum_offer_p[less_impacted_product], mcpo[less_impacted_product], cost[c->inf][less_impacted_product], aux_offer_reserve[less_impacted_product][replacement], cost[aux_offer_reserve[less_impacted_product][replacement]][less_impacted_product]);
						for (j = 0; j < prod && prod_buffer[j] >= 0; j++)
						{
							for (i = 0; i < 0.7*client && aux_offer_reserve[prod_buffer[j]][i] != -1; i++)
							{
								if (aux_offer_reserve[prod_buffer[j]][i] == c->inf)
								{
									aux_offer_reserve[prod_buffer[j]][i] = -2;
									break;
								}
							}
						}

						aux_sum_offer_c[aux_offer_reserve[less_impacted_product][replacement]]++;
						aux_sum_offer_c[c->inf]--;
						aux_offer_reserve[less_impacted_product][replacement] = -2;


					}
					else//Otherwise removes the offer from the conflicted product.
					{
						aux_solc[c->inf][less_impacted_product] = false;
						aux_prod_cost[less_impacted_product] -= cost[c->inf][less_impacted_product];
						aux_prod_rev[less_impacted_product] -= revenue[c->inf][less_impacted_product];
						aux_residual_budget[less_impacted_product] += cost[c->inf][less_impacted_product];
						fprintf(log, "Less affected product is %d with the new budget of %d and (%d,%d) offers.\n Cost of the conflicted client : %d\n", less_impacted_product, aux_residual_budget[less_impacted_product], aux_sum_offer_p[less_impacted_product], mcpo[less_impacted_product], cost[c->inf][less_impacted_product]);
						aux_sum_offer_p[less_impacted_product]--;
							aux_sum_offer_c[c->inf]--;
						for (j = 0; j < prod && prod_buffer[j] >= 0; j++)
						{
							for (i = 0; i < 0.7*client && aux_offer_reserve[prod_buffer[j]][i] != -1; i++)
							{
								if (aux_offer_reserve[prod_buffer[j]][i] == c->inf)
								{
									aux_offer_reserve[prod_buffer[j]][i] = -2;
									break;
								}
							}
						}
					}
				}
			}
		}
	}
	
	
	for (j = 0; j < prod; j++)
	{
		prod_rev[j] = aux_prod_rev[j];
		prod_cost[j] = aux_prod_cost[j];
		residual_budget[j] = aux_residual_budget[j];
		sum_offer_p[j] = aux_sum_offer_p[j];
		
		for (i = 0; i < client; i++)
		{
			sum_offer_c[i] = aux_sum_offer_c[i];
			if (aux_solc[i][j])
			{
				solc[i][j] = 1;
				/*if (j == conflicted_prod)
				{
					sum_offer_c[i]++;
				}*/
			}
			else
			{
				solc[i][j] = 0;
			}
			if (i<client*0.7 && (solp[j] > 0 || j == conflicted_prod))
			{
				offer_reserve[i][j] = aux_offer_reserve[j][i];
			}
		}
	}
	fclose(log);

	//int sumoffers[MAXC];
	for (i = 0; i < client; i++)
		sumoffers[i] = 0;
	for (j = 0; j < prod && prod_buffer[j] >= 0; j++)
	{
		if (solp[j]>0 || j == conflicted_prod)
		{
			free(aux_offer_reserve[j]);
		}
		for (i = 0; i < client; i++)
		{
			if (solc[i][j] > 0 && (solp[j]>0 || j==conflicted_prod ))
			{
				sumoffers[i]++;
			}
		}
	}
	free(aux_offer_reserve);
	for (i = 0; i < client; i++)
	{
		if (sumoffers[i] > maxofer[i])
		{
			printf("Error.\n");
		}
	}
	/*for (i = 0; i < client; i++)
		delete[] aux_solc[i];
	delete[] aux_solc;*/
	free(prod_buffer);
	free(aux_prod_cost);
	free(aux_prod_rev);
	free(aux_residual_budget);
	free(aux_sum_offer_p);
	free(aux_sum_offer_c);
	//free(aux_offer_reserve);
	fclose(log);
	return true;
}

//Same as the heristic_constructive_alter function but it takes offer conflicts that the target_prod would cause on the current offer set and avoids them.
void heuristic_constructive(int client, int prod, float hurdle,
	int **cost, int **revenue, int* maxofer,
	int* mcpo, int* budgetpo, int* fcostpo, int* offer_set,
	List** sorted_npp, int* active_clients, int* active_products,
	float* sum_cost_fix, float* sum_profit, int* prod_can, int target_prod)
{
	int client_index[MAXC];
	bool selected_offers[MAXC];

	int offer_sum = 0;
	int offer_profit = 0;
	int offer_cost = 0;
	List *aux_list;
	int i;
	for (i = 0; i < MAXC; i++)
	{
		selected_offers[i] = false;
	}
	for (i = 0; i < client; i++)
		client_index[i] = i;
	cost_matrix = cost;
	rev_matrix = revenue;
	t_prod = target_prod;
	qsort(client_index, client, sizeof(int), compare_cost);

	//Inser offers in crescent order of cost until the offer quota is met
	for (i = 0; i < client && offer_sum < mcpo[target_prod] && offer_cost <= budgetpo[target_prod]; i++)
	{
		if (active_clients[client_index[i]] > 0)
		{
			offer_set[offer_sum] = client_index[i];
			selected_offers[client_index[i]] = true;
			offer_sum++;
			offer_cost += cost[client_index[i]][target_prod];
			offer_profit += revenue[client_index[i]][target_prod];
		}
	}
	if (offer_cost <= budgetpo[target_prod] && offer_sum >= mcpo[target_prod])
		offer_set[offer_sum] = -1;
	else
	{
		offer_set[0] = -1;
		return;
	}
	qsort(offer_set, mcpo[target_prod], sizeof(int), compare_npp);
	//Perform offer swaps aiming profitability. Current offers are explored in increasing order of profit and new offers are explored in decreasing order of profit. Stops when the hurdle rate was met
	printf("\n");
	for(int tries = 0;tries<5;tries++)
	for (i = 0; i < mcpo[target_prod]; i++)
	{

			if(selected_offers[offer_set[i]])
			for (aux_list = sorted_npp[target_prod]->prox; aux_list; aux_list = aux_list->prox)
			{
				if (active_clients[aux_list->inf] > 0 && revenue[offer_set[i]][target_prod] - cost[offer_set[i]][target_prod] < revenue[aux_list->inf][target_prod] - cost[aux_list->inf][target_prod] && !selected_offers[aux_list->inf])
				if ((offer_cost - cost[offer_set[i]][target_prod] + cost[aux_list->inf][target_prod] <= budgetpo[target_prod]))
				{
					selected_offers[offer_set[i]] = false;
					offer_cost += cost[aux_list->inf][target_prod] - cost[offer_set[i]][target_prod];
					offer_profit += revenue[aux_list->inf][target_prod] - revenue[offer_set[i]][target_prod];
					offer_set[i] = aux_list->inf;
					selected_offers[aux_list->inf] = true;
					
					
				}

			}
	}
	for (aux_list = sorted_npp[target_prod]->prox, i=mcpo[target_prod]; aux_list; aux_list = aux_list->prox)
	{
		if (active_clients[aux_list->inf] > 0 && 0 < revenue[aux_list->inf][target_prod] - cost[aux_list->inf][target_prod] && !selected_offers[aux_list->inf])
			if (offer_cost + cost[aux_list->inf][target_prod] <= budgetpo[target_prod])
			{
				offer_cost += cost[aux_list->inf][target_prod]; 
				offer_profit += revenue[aux_list->inf][target_prod];
				offer_set[i] = aux_list->inf;
				selected_offers[aux_list->inf] = true;
				i++;
				if (i == client)
					break;
			}
	}
	if (i < client)
		offer_set[i] = -1;
}


//Constructive algorithm for the GA population based on the heurist_constructive
void heuristic_constructive_GEN(int client, int prod, float hurdle,
	int **cost, int **revenue, int* maxofer,
	int* mcpo, int* budgetpo, int* fcostpo, int* offer_set,
	List** sorted_npp, cromo* sol,
	int sum_cost_fix, int sum_profit, int* prod_can, int target_prod)
{

	int client_index[MAXC];
	bool selected_offers[MAXC];
	int offer_profit = 0;

	int offer_sum = 0;
	int offer_cost = 0;
	List *aux_list;
	int i;
	for (i = 0; i < MAXC; i++)
	{
		selected_offers[i] = false;
	}
	for (i = 0; i < client; i++)
		client_index[i] = i;
	cost_matrix = cost;
	rev_matrix = revenue;
	t_prod = target_prod;
	qsort(client_index, client, sizeof(int), compare_cost);

	//Inser offers in crescent order of cost until the offer quota is met
	for (i = 0; i < client && offer_sum < mcpo[target_prod] && offer_cost <= budgetpo[target_prod]; i++)
	{
		if (sol->clients[client_index[i]].offerSlots > 0)
		{
			offer_set[offer_sum] = client_index[i];
			selected_offers[client_index[i]] = true;
			offer_sum++;
			offer_cost += cost[client_index[i]][target_prod];
			offer_profit+= revenue[client_index[i]][target_prod];
		}
	}
	if (offer_cost <= budgetpo[target_prod] && offer_sum >= mcpo[target_prod])
		offer_set[offer_sum] = -1;
	else
	{
		offer_set[0] = -1;
		return;
	}
	qsort(offer_set, mcpo[target_prod], sizeof(int), compare_npp);
	//Perform offer swaps aiming profitability. Current offers are explored in increasing order of profit and new offers are explored in decreasing order of profit. Stops when the hurdle rate was met
	printf("\n");
		for (i = 0; i < mcpo[target_prod]; i++)
		{
			if (selected_offers[offer_set[i]])
				for (aux_list = sorted_npp[target_prod]->prox; aux_list; aux_list = aux_list->prox)
				{
					if (sol->clients[aux_list->inf].offerSlots > 0 && revenue[offer_set[i]][target_prod] - cost[offer_set[i]][target_prod] < revenue[aux_list->inf][target_prod] - cost[aux_list->inf][target_prod] && !selected_offers[aux_list->inf])
						if ((((float)revenue[aux_list->inf][target_prod] / (float)cost[aux_list->inf][target_prod] > (float)revenue[offer_set[i]][target_prod] / (float)cost[offer_set[i]][target_prod] || ((float)revenue[aux_list->inf][target_prod] / (float)(cost[aux_list->inf][target_prod] + (float)fcostpo[target_prod] / mcpo[target_prod])) >= 1.0 + hurdle)) && (offer_cost - cost[offer_set[i]][target_prod] + cost[aux_list->inf][target_prod] <= budgetpo[target_prod]))
						{
							selected_offers[offer_set[i]] = false;
							offer_cost += cost[aux_list->inf][target_prod] - cost[offer_set[i]][target_prod];
							offer_profit += revenue[aux_list->inf][target_prod] - revenue[offer_set[i]][target_prod];
							offer_set[i] = aux_list->inf;
							selected_offers[aux_list->inf] = true;


						}
					if (revenue[aux_list->inf][target_prod] / 1.00*cost[aux_list->inf][target_prod] < hurdle)
						break;
				}
			
		}
	for (aux_list = sorted_npp[target_prod]->prox, i = mcpo[target_prod]; aux_list; aux_list = aux_list->prox)
	{
		if (sol->clients[aux_list->inf].offerSlots > 0 && 0 < revenue[aux_list->inf][target_prod] - cost[aux_list->inf][target_prod] && !selected_offers[aux_list->inf])
			if (offer_cost + cost[aux_list->inf][target_prod] <= budgetpo[target_prod])
			{
				offer_cost += cost[aux_list->inf][target_prod];
				offer_set[i] = aux_list->inf;
				offer_profit += revenue[aux_list->inf][target_prod];
				selected_offers[aux_list->inf] = true;
				i++;
				if (i == client)
					break;
			}
		if (offer_profit / 1.00*(offer_cost + fcostpo[target_prod]) > hurdle)
			break;
	}
	if (i < client)
		offer_set[i] = -1;
}

//Same as the resolve_conflicts function but it inacts the changes on a genetic algorithm solution
bool resolve_conflicts_GEN(int **conflict_matrix, cromo *n, int conflicted_prod, int prod, int client, int **cost, int **revenue, int *fcostpo, int *maxofer, int *mcpo, int *budgetpo, List **sorted_npp, int *sum_offer_c, int *sum_offer_p, int* sum_offer_r, int **offer_reserve, int *reserve_cost, int* prod_cost, int *prod_rev, int *conflicts)
{

	int i, j, offer_count, block_impact, less_impacted_product, replacement;
	bool **aux_solc = generate_2D_matrix_bool(client, prod);
	int *aux_prod_cost = (int*)malloc(sizeof(int)*prod);
	int *aux_prod_rev = (int*)malloc(sizeof(int)*prod);
	int *aux_residual_budget = (int*)malloc(sizeof(int)*prod);
	int *aux_sum_offer_p = (int*)malloc(sizeof(int)*prod);
	int *aux_sum_offer_c = (int*)malloc(sizeof(int)*client);
	int **aux_offer_reserve = (int**)malloc(sizeof(int*)*prod);
	int *prod_buffer = (int*)malloc(sizeof(int)*prod);
	List *c;
	FILE *log = fopen("Log_conflicts.txt", "a+");
	fprintf(log, "-------------------------------Conflicted prod %d --------------------------------\n", conflicted_prod);

	int sumoffers[MAXC];
	for (i = 0; i < client; i++)
	{
		aux_sum_offer_c[i] = sum_offer_c[i];
		for (j = 0; j < prod; j++)
		{
			if (n->clients[i].offers[j] > 0)
			{
				aux_solc[i][j] = true;
			}
			else
				aux_solc[i][j] = false;
		}
	}
	for (j = 0; j < prod; j++)
	{
		aux_prod_cost[j] = prod_cost[j];
		aux_residual_budget[j] = n->budget[j];
		fprintf(log, "Product %d original budget is %d\n", i, n->budget[j]);
		aux_prod_rev[j] = prod_rev[j];
		aux_sum_offer_p[j] = sum_offer_p[j];
		if (n->offeredProducts[j] || j == conflicted_prod)
		{
			aux_offer_reserve[j] = (int*)malloc(sizeof(int)*client);
			for (i = 0; i < client*0.7; i++)
				aux_offer_reserve[j][i] = offer_reserve[i][j];
		}
	}
	//For each client in decreasing order of profit for the conflicted product
	for (c = sorted_npp[conflicted_prod]->prox; c; c = c->prox)
	{
		//If the conflicted product is offered to the client
		if (aux_solc[c->inf][conflicted_prod])
		{
			aux_sum_offer_c[c->inf]++;
			//If the amount of offers in aux_sum_ffer_c exceeds the maximum offer restraint for the conflicted product
			if (aux_sum_offer_c[c->inf] > maxofer[c->inf])
			{
				for (offer_count = 0, j = 0, i = 0; j < prod; j++)
				{
					if (aux_solc[c->inf][j] && n->offeredProducts[j])
					{
						offer_count++;
						prod_buffer[i] = j;
						i++;
					}
				}
				if (i < prod)
				{
					prod_buffer[i] = conflicted_prod;
				}
				if (i + 1 < prod)
				{
					prod_buffer[i + 1] = -1;
				}
				replacement = -1;

				fprintf(log, "Conflicted client %d\n", c->inf);
				//Explores other products in search of a product that can receive the exceding clients offer
				//Keeps track of the swap that will minimise profit loss
				for (j = 0, less_impacted_product = -1, block_impact = INT_MAX; j < prod && prod_buffer[j] >= 0; j++)
				{

					if (sum_offer_r[prod_buffer[j]] > 0)
					{
						for (i = 0; i < 0.7*client && aux_offer_reserve[prod_buffer[j]][i] != -1; i++)
						{
							if (aux_sum_offer_c[aux_offer_reserve[prod_buffer[j]][i]] + 1 > maxofer[aux_offer_reserve[prod_buffer[j]][i]])
							{
								aux_offer_reserve[prod_buffer[j]][i] = -2;
								continue;
							}
							if (aux_offer_reserve[prod_buffer[j]][i] == -2)
								continue;
							if (aux_residual_budget[prod_buffer[j]] - cost[aux_offer_reserve[prod_buffer[j]][i]][prod_buffer[j]] >= 0 && revenue[c->inf][prod_buffer[j]] - cost[c->inf][prod_buffer[j]] - (revenue[aux_offer_reserve[prod_buffer[j]][i]][prod_buffer[j]] - cost[aux_offer_reserve[prod_buffer[j]][i]][prod_buffer[j]]) < block_impact)
							{
								block_impact = revenue[c->inf][prod_buffer[j]] - cost[c->inf][prod_buffer[j]] - (revenue[aux_offer_reserve[prod_buffer[j]][i]][prod_buffer[j]] - cost[aux_offer_reserve[prod_buffer[j]][i]][prod_buffer[j]]);
								less_impacted_product = prod_buffer[j];
								replacement = i;
								break;
							}
						}
					}
					//If the offer removal would make the conflicted product to not meet its offer quota, marks the conflict as unsolvable
					if (aux_sum_offer_p[prod_buffer[j]] > mcpo[prod_buffer[j]])
					{
						if ((revenue[c->inf][prod_buffer[j]] - cost[c->inf][prod_buffer[j]]) < block_impact)
						{
							block_impact = revenue[c->inf][prod_buffer[j]] - cost[c->inf][prod_buffer[j]];
							less_impacted_product = prod_buffer[j];
							if (replacement >= 0)
								replacement = -1;
						}
					}
				}
				//Unsolvable conflict. 
				if (less_impacted_product == -1)
				{

					fprintf(log, "Conflict impossible to solve, closing process...\n");
					n->budget[conflicted_prod] = budgetpo[conflicted_prod];
					sum_offer_p[conflicted_prod] = 0;
					prod_rev[conflicted_prod] = 0;
					prod_cost[conflicted_prod] = 0;
					for (i = 0; i < client; i++)
						delete[] aux_solc[i];
					delete[] aux_solc;
					free(prod_buffer);
					free(aux_prod_cost);
					free(aux_prod_rev);
					free(aux_residual_budget);
					fclose(log);
					return false;
				}
				else
				{
					if (replacement >= 0)//If a swap was found, performs the swap.
					{
						aux_solc[aux_offer_reserve[less_impacted_product][replacement]][less_impacted_product] = true;
						aux_solc[c->inf][less_impacted_product] = false;
						aux_prod_cost[less_impacted_product] += cost[aux_offer_reserve[less_impacted_product][replacement]][less_impacted_product] - cost[c->inf][less_impacted_product];
						aux_prod_rev[less_impacted_product] += revenue[aux_offer_reserve[less_impacted_product][replacement]][less_impacted_product] - revenue[c->inf][less_impacted_product];
						aux_residual_budget[less_impacted_product] += cost[c->inf][less_impacted_product] - cost[aux_offer_reserve[less_impacted_product][replacement]][less_impacted_product];
						fprintf(log, "Less affected product is %d with the new budget of %d and (%d,%d) offers. Replacement needed.\n Cost of the conflicted client  : %d Cost of the replacement (%d): %d\n", less_impacted_product, aux_residual_budget[less_impacted_product], aux_sum_offer_p[less_impacted_product], mcpo[less_impacted_product], cost[c->inf][less_impacted_product], aux_offer_reserve[less_impacted_product][replacement], cost[aux_offer_reserve[less_impacted_product][replacement]][less_impacted_product]);
						for (j = 0; j < prod && prod_buffer[j] >= 0; j++)
						{
							for (i = 0; i < 0.7*client && aux_offer_reserve[prod_buffer[j]][i] != -1; i++)
							{
								if (aux_offer_reserve[prod_buffer[j]][i] == c->inf)
								{
									aux_offer_reserve[prod_buffer[j]][i] = -2;
									break;
								}
							}
						}
						aux_sum_offer_c[aux_offer_reserve[less_impacted_product][replacement]]++;
						aux_sum_offer_c[c->inf]--;
						aux_offer_reserve[less_impacted_product][replacement] = -2;


					}
					else//Otherwise removes the offer from the conflicted product.
					{
						aux_solc[c->inf][less_impacted_product] = false;
						aux_prod_cost[less_impacted_product] -= cost[c->inf][less_impacted_product];
						aux_prod_rev[less_impacted_product] -= revenue[c->inf][less_impacted_product];
						aux_residual_budget[less_impacted_product] += cost[c->inf][less_impacted_product];
						fprintf(log, "Less affected product is %d with the new budget of %d and (%d,%d) offers.\n Cost of the conflicted client : %d\n", less_impacted_product, aux_residual_budget[less_impacted_product], aux_sum_offer_p[less_impacted_product], mcpo[less_impacted_product], cost[c->inf][less_impacted_product]);
						aux_sum_offer_p[less_impacted_product]--;
						aux_sum_offer_c[c->inf]--;
						for (j = 0; j < prod && prod_buffer[j] >= 0; j++)
						{
							for (i = 0; i < 0.7*client && aux_offer_reserve[prod_buffer[j]][i] != -1; i++)
							{
								if (aux_offer_reserve[prod_buffer[j]][i] == c->inf)
								{
									aux_offer_reserve[prod_buffer[j]][i] = -2;
									break;
								}
							}
						}
					}
				}
			}
		}
	}


	for (j = 0; j < prod; j++)
	{
		prod_rev[j] = aux_prod_rev[j];
		prod_cost[j] = aux_prod_cost[j];
		n->offeredProducts[j] = aux_residual_budget[j];
		sum_offer_p[j] = aux_sum_offer_p[j];

		for (i = 0; i < client; i++)
		{
			sum_offer_c[i] = aux_sum_offer_c[i];
			if (aux_solc[i][j])
			{
				n->clients[i].offers[j] = true;
			}
			else
			{
				n->clients[i].offers[j] = true;
			}
			if (i < client*0.7 && (n->offeredProducts[j] || j == conflicted_prod))
			{
				offer_reserve[i][j] = aux_offer_reserve[j][i];
			}
		}
	}
	fclose(log);
	for (i = 0; i < client; i++)
		sumoffers[i] = 0;
	for (j = 0; j < prod && prod_buffer[j] >= 0; j++)
	{
		if (n->offeredProducts[j] || j == conflicted_prod)
		{
			free(aux_offer_reserve[j]);
		}
		for (i = 0; i < client; i++)
		{
			if (n->clients[i].offers[j]  && (n->offeredProducts[j] || j == conflicted_prod))
			{
				sumoffers[i]++;
			}
		}
	}
	free(aux_offer_reserve);
	for (i = 0; i < client; i++)
	{
		if (sumoffers[i] > maxofer[i])
		{
			printf("Error.\n");
		}
	}
	for (i = 0; i < client; i++)
		delete[] aux_solc[i];
	delete[] aux_solc;
	free(prod_buffer);
	free(aux_prod_cost);
	free(aux_prod_rev);
	free(aux_residual_budget);
	fclose(log);
	return true;
}

//Constructs a solution for the problem instance starting with a scenario where every product is offered to every client, it then starts removing offers to make each product offer set viable. 
//After each product has a valid offer set, it tries to resolve conflicts generated by the maximum offer number constraint for each client by swaping offers in a way that would cause less loss of profit.
void alternative_constructive_algorithm(int client, int prod, float hurdle,
	int **cost, int **revenue, int* maxofer,
	int* mcpo, int* budgetpo, int* fcostpo,
	int **solc, int* solp,
	List** sorted_npp, int* active_clients, int* active_products,
	float* sum_cost_fix, float* sum_profit, int* prod_can)
{
	int i, j, k, l, selected_client, selected_product, best_profit, profit, max_cost, tries, average_goal, profit_dilution;
	int *prod_cost = (int*)malloc(sizeof(int)*prod);
	int *prod_rev = (int*)malloc(sizeof(int)*prod);
	int *budget_slack = (int*)malloc(sizeof(int)*prod);
	int *minimum_cost = (int*)malloc(sizeof(int)*prod);
	int *average_cost = (int*)malloc(sizeof(int)*prod);
	int *sum_offer_r = (int*)malloc(sizeof(int)*prod);
	float solution_cost;
	int **offer_reserve = generate_2D_matrix_int(client*0.7, prod);
	conflicts = (int*)malloc(sizeof(int)*client);
	int *sum_offers_p = (int*)malloc(sizeof(int)*prod);
	int *sum_offers_c = (int*)malloc(sizeof(int)*client);
	int *residual_budget = (int*)malloc(sizeof(int)*prod);
	List **product_aux = (List**)malloc(sizeof(List)*prod);
	bool *finished = (bool*)malloc(sizeof(bool)*prod);
	int **conflict_matrix = generate_2D_matrix_int(client, prod);
	int* prod_index = (int*)malloc(sizeof(int)*prod);
	FILE *log = fopen("Log.txt","w+");
	bool can_detection = false;
	int offer_set[MAXC];
	int prod_set[MAXPROD];
	if (!sum_profit)
	{
		original_prod_number = prod;
		sum_profit1 = (int*)malloc(sizeof(int)*prod);
		reserve_cost = (int*)malloc(sizeof(int)*prod);
		reserve_rev = (int*)malloc(sizeof(int)*prod);
	}
	else if (original_prod_number != prod)
	{
		free(sum_profit1);
		free(reserve_cost);
		free(reserve_rev);
		sum_profit1 = (int*)malloc(sizeof(int)*prod);
		reserve_cost = (int*)malloc(sizeof(int)*prod);
		reserve_rev = (int*)malloc(sizeof(int)*prod);
	}
	for (i = 0; i < prod; i++)
	{
		solp[i] = 0;
		residual_budget[i] = budgetpo[i];
		fprintf(log,"Product %d original budget is %d\n", i, residual_budget[i]);
		budget_slack[i] = 0;
		sum_offers_p[i] = 0;
		minimum_cost[i] = INT_MAX;
		average_cost[i] = 0;
		conflicts[i] = 0;
		prod_cost[i] = 0;
		prod_rev[i] = 0;
		for (j = 0; j < client; j++)
		{
			solc[j][i] = 0;
			average_cost[i] += cost[j][i];
			if (minimum_cost[i] > cost[j][i])
			{
				minimum_cost[i] = cost[j][i];
			}
		}
		average_cost[i] = average_cost[i] / client;
	}

	printf("\n");
	for (i = 0; i < prod; i++)
	{
		printf("Budget for product %d: %d. -> ", i, residual_budget[i]);
	}
	printf("\n");

	for (j = 0; j < client; j++)
	{
		sum_offers_c[j] = 0;
	}
	for (i = 0; i < prod; i++)
	{
		product_aux[i] = sorted_npp[i]->prox;
		finished[i] = false;
	}
	for (i = 0; i < client; i++)
	{
		for (j = 0; j < prod; j++)
		{
			conflict_matrix[i][j] = -1;
		}
	}

	//Adds offers to each product amounting to 70% of the client population. Keeps track of on how much the product budget was exceeded. Exceeding offers are marked as reserve.
	//The offers are inserted in decresing order of profit.
	for (j = 0; j < prod; j++)
	{
		profit_dilution = fcostpo[j] / mcpo[j];
		fprintf(log, "Starting offer set construction for the product %d. Starting budget: %d\n", j, residual_budget[j]);
		for (i=0, reserve_cost[j]=0, sum_offer_r[j]=0;product_aux[j] && !finished[j]; product_aux[j] = product_aux[j]->prox)
		{
			if (cost[product_aux[j]->inf][j] + reserve_cost[j] <= residual_budget[j] + 4*budgetpo[j] && (revenue[product_aux[j]->inf][j]/(cost[product_aux[j]->inf][j])) >= hurdle)
			{
				if (cost[product_aux[j]->inf][j] <= residual_budget[j])
				{
					solc[product_aux[j]->inf][j] = 1;
					residual_budget[j] -= cost[product_aux[j]->inf][j];
					prod_cost[j] += cost[product_aux[j]->inf][j];
					prod_rev[j] += revenue[product_aux[j]->inf][j];
					sum_offers_p[j]++;
					sum_offers_c[product_aux[j]->inf]++;
					fprintf(log, "Client %d was added with a cost of %d. Remaining budget %d.\n", product_aux[j]->inf, cost[product_aux[j]->inf][j], residual_budget[j]);
				}
				else if(i<0.7*client)
				{
					offer_reserve[i][j] = product_aux[j]->inf;
					reserve_cost[j]+= cost[product_aux[j]->inf][j];
					reserve_rev[j] += revenue[product_aux[j]->inf][j];
					sum_offer_r[j]++;
					fprintf(log, "-->Added an offer made to the client %d at a cost of %d to the reserve.\n", product_aux[j]->inf, cost[product_aux[j]->inf][j]);
					i++;
				}
				
				for (k = 0; k < prod; k++)
				{
					if (conflict_matrix[product_aux[j]->inf][k] == -1)
					{
						conflict_matrix[product_aux[j]->inf][k] = j;
						break;
					}
				}
				if(sum_offers_p[j]==mcpo[j])
				{
					budget_slack[j] = budgetpo[j] - residual_budget[j];
				}
			}
			else if (residual_budget[j] < minimum_cost[j])
			{
				finished[j] = true;
				if (sum_offers_p[j] < mcpo[j])
				{
					budget_slack[j] = (sum_offers_p[j]-mcpo[j]) * average_cost[j];
				}
			}
		}
		if (i >= 0.7*client)
		{
			break;
		}
		offer_reserve[i][j] = -1;
	}
	printf("\n");
	for (i = 0; i < prod; i++)
	{
		printf("Budget for product %d: %d. -> ", i, residual_budget[i]);
	}
	printf("\n");
	//Swaps current offers from offers in the reserve with current offers in an attempt to reduce the budge slack and increase the profit.
	for (j = 0; j < prod; j++)
	{
		if (sum_offers_p[j] < mcpo[j])
		{
			fprintf(log, "Complementing procedure for the product %d. Residual budget: %d\n", j, residual_budget[j]);
			for (tries = 0; tries < mcpo[j] && budget_slack[j] < 0; tries++)
			{
				for (max_cost = 0, i = 0, product_aux[j] = sorted_npp[j]->prox; i < sum_offers_p[j] && product_aux[j]; product_aux[j] = product_aux[j]->prox, i++)
				{
					if (solc[product_aux[j]->inf][j] == 1)
						if (cost[product_aux[j]->inf][j] > max_cost)
						{
							max_cost = cost[product_aux[j]->inf][j];
							selected_client = product_aux[j]->inf;
						}
				}
				for (product_aux[j] = sorted_npp[j]->prox; i < sum_offers_p[j] && product_aux[j]; product_aux[j] = product_aux[j]->prox, i++)
				{
					if (solc[product_aux[j]->inf][j] == 0)
						if (cost[product_aux[j]->inf][j] < max_cost && cost[product_aux[j]->inf][j] <= average_cost[j])
						{
							solc[selected_client][j] = 0;
							solc[product_aux[j]->inf][j] = 1;
							residual_budget[j] += cost[selected_client][j] - cost[product_aux[j]->inf][j];
							prod_cost[j] += cost[product_aux[j]->inf][j] - cost[selected_client][j];
							prod_rev[j] += revenue[product_aux[j]->inf][j] - revenue[selected_client][j];
							selected_client = product_aux[j]->inf;
							fprintf(log, "Replacing offer made to the client %d at a cost of %d for an offer for the client %d at a cost of %d. Average Cost: %f\n", selected_client, cost[selected_client][j], product_aux[j]->inf, cost[product_aux[j]->inf][j], (float)((fcostpo[j]+prod_cost[j])/sum_offers_p[j]));
							budget_slack[j] += cost[selected_client][j] - cost[product_aux[j]->inf][j];
						}
				}
			}
			average_goal = budgetpo[j] / mcpo[j];
			for (tries = 0,i=0, sum_offer_r[j]=0, reserve_cost[j]=0; residual_budget[j] < minimum_cost[j] && sum_offers_p[j] < mcpo[j] && tries < 50; tries++)
			{
				for (product_aux[j] = sorted_npp[j]->prox; product_aux[j] && residual_budget[j] > minimum_cost[j]; product_aux[j] = product_aux[j]->prox)
				{
					if ((prod_cost[j] + cost[product_aux[j]->inf][j]) / (sum_offers_p[j] + 1) <= average_goal && residual_budget[j] >= cost[product_aux[j]->inf][j])
					{
						solc[product_aux[j]->inf][j] = 1;
						residual_budget[j] -= cost[product_aux[j]->inf][j];
						prod_cost[j] += cost[product_aux[j]->inf][j];
						prod_rev[j] += revenue[product_aux[j]->inf][j];
						sum_offers_p[j]++;
						sum_offers_c[product_aux[j]->inf]++;
						selected_client = product_aux[j]->inf;
						fprintf(log, "Added an offer made to the client %d at a cost of %d.  Average Cost: %f\n", selected_client, cost[product_aux[j]->inf][j], (float)((fcostpo[j] + prod_cost[j]) / sum_offers_p[j]));
						if (sum_offers_p[j] == mcpo[i])
							budget_slack[j] = budgetpo[j] - residual_budget[j];

					}
					else if((prod_cost[j] + cost[product_aux[j]->inf][j]) / (sum_offers_p[j] + 1) <= average_goal && !(residual_budget[j] >= cost[product_aux[j]->inf][j]) && i<0.4*client)
					{

						offer_reserve[i][j] = product_aux[j]->inf;
						offer_reserve[i][j] = product_aux[j]->inf;
						reserve_cost[j] += cost[product_aux[j]->inf][j];
						fprintf(log, "Added an offer made to the client %d at a cost of %d to the reserve.\n", product_aux[j]->inf, cost[product_aux[j]->inf][j]);
						sum_offer_r[j]++;
						i++;
					}
				}
			}
		}
	}
	printf("\n");
	for (i = 0; i < prod; i++)
	{
		printf("Budget for product %d: %d. -> ", i, residual_budget[i]);
	}
	printf("\n");

	for (j = 0; j < prod; j++)
	{
		prod_index[j] = j;
		sum_profit1[j] = prod_rev[j] - prod_cost[j] - fcostpo[j];
		for (i = 0; i < client; i++)
		{
			if (solc[i][j] == 1)
			{
				if (sum_offers_c[i] > maxofer[i])
				{
					conflicts[j]++;
				}
			}
		}
	}
	qsort((void*)prod_index, prod, sizeof(int), compare2);

	int sumoffers[MAXC];


	for (j = 0; j < client; j++)
	{
		sum_offers_c[j] = 0;
	}
	solution_cost = 0;
	for (i = 0; i < prod; i++)
	{
		prod_set[j] = 1;
	}
	//Attempt to solve conflicts generated by the client offer limit constraint.
	for (j = 0; j < prod; j++)
	{
		if (sum_offers_p[prod_index[j]] >= mcpo[prod_index[j]])
		{
			if (prod_set[prod_index[j]] == 1 && resolve_conflicts(conflict_matrix, solc, solp, prod_index[j], prod, client, cost, revenue, fcostpo, maxofer, mcpo, budgetpo, sorted_npp, sum_offers_c, sum_offers_p, sum_offer_r, offer_reserve, reserve_cost, prod_cost,prod_rev,residual_budget, conflicts))
			{
				solp[prod_index[j]] = 1;
				if (prod_can[prod_index[j]] > 0)
				{
					prod_set[prod_can[prod_index[j]]] = 0;
				}
				solution_cost += prod_rev[prod_index[j]] - prod_cost[prod_index[j]] - fcostpo[prod_index[j]];
				check_values2(solc, solp, fcostpo, cost, revenue, prod_cost, prod_rev, solution_cost, prod, client);
				
			}
			else
			{
				for (i = 0; i < client; i++)
					solc[i][prod_index[j]] = 0;
				sum_offers_p[prod_index[j]] = 0;
				residual_budget[prod_index[j]] = budgetpo[prod_index[j]];
				prod_cost[prod_index[j]] = 0;
				prod_rev[prod_index[j]] = 0;
				solp[prod_index[j]] = 0;
			}
		}
		else
		{
			for (i = 0; i < client; i++)
				solc[i][prod_index[j]] = 0;
			sum_offers_p[prod_index[j]] = 0;
			residual_budget[prod_index[j]] = budgetpo[prod_index[j]];
			prod_cost[prod_index[j]] = 0;
			prod_rev[prod_index[j]] = 0;
			solp[prod_index[j]] = 0;

		}
	}

	
	//Attempts to add aditional offers on the solution resulting from the conflict resolution process.
	for (j = 0; j < prod; j++)
	{
		if (solp[prod_index[j]] > 0)
		{
			fprintf(log, "Initiating the completion process for the product %d with a original budget of %d.\n", prod_index[j], residual_budget[prod_index[j]]);
			for (product_aux[prod_index[j]] = sorted_npp[prod_index[j]]->prox; product_aux[prod_index[j]] && residual_budget[prod_index[j]]>=minimum_cost[prod_index[j]]; product_aux[prod_index[j]] = product_aux[prod_index[j]]->prox)
			{
				if (cost[product_aux[prod_index[j]]->inf][prod_index[j]] <= residual_budget[prod_index[j]] && (revenue[product_aux[prod_index[j]]->inf][prod_index[j]])/(cost[product_aux[prod_index[j]]->inf][prod_index[j]]) >= hurdle && sum_offers_c[product_aux[prod_index[j]]->inf] < maxofer[product_aux[prod_index[j]]->inf] && (solc[product_aux[prod_index[j]]->inf][prod_index[j]]<1))
				{
					solc[product_aux[prod_index[j]]->inf][prod_index[j]] = 1;
					residual_budget[prod_index[j]] -= cost[product_aux[prod_index[j]]->inf][prod_index[j]];
					prod_cost[prod_index[j]] += cost[product_aux[prod_index[j]]->inf][prod_index[j]];
					prod_rev[prod_index[j]] += revenue[product_aux[prod_index[j]]->inf][prod_index[j]];
					sum_offers_p[prod_index[j]]++;
					sum_offers_c[product_aux[prod_index[j]]->inf]++;
					fprintf(log, "New offer to the client %d added with a cost of %d, resulting in a residual budget of budget of %d.\n", product_aux[prod_index[j]]->inf, cost[product_aux[prod_index[j]]->inf][prod_index[j]], residual_budget[prod_index[j]]);
				}
			}
		}
		if (sum_offers_p[prod_index[j]] < mcpo[prod_index[j]])
		{
			fprintf(log, "Product %d did not met its minimum offer requirement. (%d/%d)\n",prod_index[j],sum_offers_p[prod_index[j]], mcpo[prod_index[j]] );
			solp[prod_index[j]] = 0;
			for (i = 0; i < client; i++)
			{
				solc[i][prod_index[j]] = 0;
			}
		}
	}
	compute_solution_value(client, prod, hurdle,
		cost, revenue, maxofer,
		mcpo, budgetpo, fcostpo,
		solc, solp, &solution_cost, prod_can,false);
	*sum_cost_fix = 0;
	*sum_profit = 0;
	for (i = 0; i < prod; i++)
	{
		if (solp[i]>0)
		{
			*sum_cost_fix += fcostpo[i] + prod_cost[i];
			*sum_profit += prod_rev[i];
		}
	}
	check_values2(solc, solp, fcostpo, cost, revenue, prod_cost, prod_rev, solution_cost, prod, client);
	printf("\n");
	for (i = 0; i < prod; i++)
	{
		printf("Budget for product %d: %d. -> ", i, residual_budget[i]);
	}
	printf("\n");
	fclose(log);
	free(prod_cost);
	free(prod_rev);
	free(budget_slack);
	free(minimum_cost);
	free(average_cost);
	free(sum_offer_r);
	free(conflicts);
	free(sum_offers_p);
	free(sum_offers_c);
	free(residual_budget);
	free(finished);
	free(prod_index);
	free(product_aux);
	for (i = 0; i < client*0.7; i++)
			delete[] offer_reserve[i];
		delete[] offer_reserve;
	for (i = 0; i < client; i++)
		delete[] conflict_matrix[i];
	delete[] conflict_matrix;
}

//Same as the alternative_constructive function but generates a set of genes for the genetic algorithm by blocking diferent combinations of products
void alternative_constructive_algorithm_GEN(int client, int prod, float hurdle,
	int **cost, int **revenue, int* maxofer,
	int* mcpo, int* budgetpo, int* fcostpo,
	cromo *pop,
	List** sorted_npp,
	int* prod_can, int popSize, int initial_pos)
{
	int i, j, k, l, selected_client, selected_product, best_profit, profit, max_cost, tries, average_goal, profit_dilution;
	int *prod_cost = (int*)malloc(sizeof(int)*prod);
	int *prod_rev = (int*)malloc(sizeof(int)*prod);
	int *budget_slack = (int*)malloc(sizeof(int)*prod);
	int *minimum_cost = (int*)malloc(sizeof(int)*prod);
	int *average_cost = (int*)malloc(sizeof(int)*prod);
	int *sum_offer_r = (int*)malloc(sizeof(int)*prod);
	float solution_cost;
	int **offer_reserve = generate_2D_matrix_int(client*0.7, prod);
	conflicts = (int*)malloc(sizeof(int)*client);
	int *sum_offers_p = (int*)malloc(sizeof(int)*prod);
	int *sum_offers_c = (int*)malloc(sizeof(int)*client);
	//int *n->budget = (int*)malloc(sizeof(int)*prod);
	List **product_aux = (List**)malloc(sizeof(List)*prod);
	bool *finished = (bool*)malloc(sizeof(bool)*prod);
	int **conflict_matrix = generate_2D_matrix_int(client, prod);
	int* prod_index = (int*)malloc(sizeof(int)*prod);
	bool blocked_prod[MAXPROD];
	cromo *n;

	if (!sum_profit1)
	{
		original_prod_number = prod;
		sum_profit1 = (int*)malloc(sizeof(int)*prod);
		reserve_cost = (int*)malloc(sizeof(int)*prod);
		reserve_rev = (int*)malloc(sizeof(int)*prod);
	}
	else if (original_prod_number != prod)
	{
		free(sum_profit1);
		free(reserve_cost);
		free(reserve_rev);
		sum_profit1 = (int*)malloc(sizeof(int)*prod);
		reserve_cost = (int*)malloc(sizeof(int)*prod);
		reserve_rev = (int*)malloc(sizeof(int)*prod);
	}
	for (int c = initial_pos; c < popSize; c++)
	{
		FILE *log = fopen("Log.txt", "w+");
		fprintf(log, "Gene number: %d\n", c);
		n = &pop[c];
		for (i = 0; i < prod; i++)
		{
			n->offeredProducts[i] = false;
			n->budget[i] = budgetpo[i];
			fprintf(log, "Product %d original budget is %d\n", i, n->budget[i]);
			budget_slack[i] = 0;
			sum_offers_p[i] = 0;
			minimum_cost[i] = INT_MAX;
			average_cost[i] = 0;
			conflicts[i] = 0;
			prod_cost[i] = 0;
			prod_rev[i] = 0;
			if (c > 0)
			{
				if ((rand() % 100) + 1 <= 20)
				{
					blocked_prod[i] = true;
				}
				else
					blocked_prod[i] = false;
			}
			for (j = 0; j < client; j++)
			{
				n->clients[j].offers[i] = false;
				average_cost[i] += cost[j][i];
				if (minimum_cost[i] > cost[j][i])
				{
					minimum_cost[i] = cost[j][i];
				}
			}
			average_cost[i] = average_cost[i] / client;
		}

		printf("\n");
		for (i = 0; i < prod; i++)
		{
			printf("Budget for product %d: %d. -> ", i, n->budget[i]);
		}
		printf("\n");

		for (j = 0; j < client; j++)
		{
			sum_offers_c[j] = 0;
		}
		for (i = 0; i < prod; i++)
		{
			product_aux[i] = sorted_npp[i]->prox;
			finished[i] = false;
		}
		for (i = 0; i < client; i++)
		{
			for (j = 0; j < prod; j++)
			{
				conflict_matrix[i][j] = -1;
			}
		}

		for (j = 0; j < prod; j++)
		{
			if (blocked_prod != NULL)
			{
				if (blocked_prod[j])
				{
					continue;
				}
			}
			profit_dilution = fcostpo[j] / mcpo[j];
			fprintf(log, "Starting offer set construction for the product %d. Starting budget: %d\n", j, n->budget[j]);
			//Adds offers to each product amounting to 70% of the client population. Keeps track of on how much the product budget was exceeded. Exceeding offers are marked as reserve.
			//The offers are inserted in decresing order of profit.
			for (i = 0, reserve_cost[j] = 0, sum_offer_r[j] = 0; product_aux[j] && !finished[j]; product_aux[j] = product_aux[j]->prox)
			{
				if (cost[product_aux[j]->inf][j] + reserve_cost[j] <= n->budget[j] + 4 * budgetpo[j] && (revenue[product_aux[j]->inf][j] / (cost[product_aux[j]->inf][j])) >= hurdle)
				{
					if (cost[product_aux[j]->inf][j] <= n->budget[j])
					{
						n->clients[product_aux[j]->inf].offers[j] = true;
						n->budget[j] -= cost[product_aux[j]->inf][j];
						prod_cost[j] += cost[product_aux[j]->inf][j];
						prod_rev[j] += revenue[product_aux[j]->inf][j];
						sum_offers_p[j]++;
						sum_offers_c[product_aux[j]->inf]++;
						fprintf(log, "Client %d was added with a cost of %d. Remaining budget %d.\n", product_aux[j]->inf, cost[product_aux[j]->inf][j], n->budget[j]);
					}
					else if (i < 0.7*client)
					{
						offer_reserve[i][j] = product_aux[j]->inf;
						reserve_cost[j] += cost[product_aux[j]->inf][j];
						reserve_rev[j] += revenue[product_aux[j]->inf][j];
						sum_offer_r[j]++;
						fprintf(log, "-->Added an offer made to the client %d at a cost of %d to the reserve.\n", product_aux[j]->inf, cost[product_aux[j]->inf][j]);
						i++;
					}
					for (k = 0; k < prod; k++)
					{
						if (conflict_matrix[product_aux[j]->inf][k] == -1)
						{
							conflict_matrix[product_aux[j]->inf][k] = j;
							break;
						}
					}
					if (sum_offers_p[j] == mcpo[j])
					{
						budget_slack[j] = budgetpo[j] - n->budget[j];
					}
				}
				else if (n->budget[j] < minimum_cost[j])
				{
					finished[j] = true;
					if (sum_offers_p[j] < mcpo[j])
					{
						budget_slack[j] = (sum_offers_p[j] - mcpo[j]) * average_cost[j];
					}
				}
			}
			offer_reserve[i][j] = -1;
		}
		printf("\n");
		for (i = 0; i < prod; i++)
		{
			printf("Budget for product %d: %d. -> ", i, n->budget[i]);
		}
		printf("\n");
		//Swaps current offers from offers in the reserve with current offers in an attempt to reduce the budge slack and increase the profit.
		for (j = 0; j < prod; j++)
		{
			if (sum_offers_p[j] < mcpo[j])
			{
				fprintf(log, "Complementing procedure for the product %d. Residual budget: %d\n", j, n->budget[j]);
				for (tries = 0; tries < mcpo[j] && budget_slack[j] < 0; tries++)
				{
					for (max_cost = 0, i = 0, product_aux[j] = sorted_npp[j]->prox; i < sum_offers_p[j] && product_aux[j]; product_aux[j] = product_aux[j]->prox, i++)
					{
						if (n->clients[product_aux[j]->inf].offers[j] == 1)
							if (cost[product_aux[j]->inf][j] > max_cost)
							{
								max_cost = cost[product_aux[j]->inf][j];
								selected_client = product_aux[j]->inf;
							}
					}
					for (product_aux[j] = sorted_npp[j]->prox; i < sum_offers_p[j] && product_aux[j]; product_aux[j] = product_aux[j]->prox, i++)
					{
						if (n->clients[product_aux[j]->inf].offers[j] == 0)
							if (cost[product_aux[j]->inf][j] < max_cost && cost[product_aux[j]->inf][j] <= average_cost[j])
							{
								n->clients[selected_client].offers[j] = 0;
								n->clients[product_aux[j]->inf].offers[j] = 1;
								n->budget[j] += cost[selected_client][j] - cost[product_aux[j]->inf][j];
								prod_cost[j] += cost[product_aux[j]->inf][j] - cost[selected_client][j];
								prod_rev[j] += revenue[product_aux[j]->inf][j] - revenue[selected_client][j];
								selected_client = product_aux[j]->inf;
								fprintf(log, "Replacing offer made to the client %d at a cost of %d for an offer for the client %d at a cost of %d. Average Cost: %f\n", selected_client, cost[selected_client][j], product_aux[j]->inf, cost[product_aux[j]->inf][j], (float)((fcostpo[j] + prod_cost[j]) / sum_offers_p[j]));
								budget_slack[j] += cost[selected_client][j] - cost[product_aux[j]->inf][j];
							}
					}
				}
				average_goal = budgetpo[j] / mcpo[j];
				for (tries = 0, i = 0, sum_offer_r[j] = 0, reserve_cost[j] = 0; n->budget[j] < minimum_cost[j] && sum_offers_p[j] < mcpo[j] && tries < 50; tries++)
				{
					for (product_aux[j] = sorted_npp[j]->prox; product_aux[j] && n->budget[j] > minimum_cost[j]; product_aux[j] = product_aux[j]->prox)
					{
						if ((prod_cost[j] + cost[product_aux[j]->inf][j]) / (sum_offers_p[j] + 1) <= average_goal && n->budget[j] >= cost[product_aux[j]->inf][j])
						{
							n->clients[product_aux[j]->inf].offers[j] = 1;
							n->budget[j] -= cost[product_aux[j]->inf][j];
							prod_cost[j] += cost[product_aux[j]->inf][j];
							prod_rev[j] += revenue[product_aux[j]->inf][j];
							sum_offers_p[j]++;
							sum_offers_c[product_aux[j]->inf]++;
							selected_client = product_aux[j]->inf;
							fprintf(log, "Added an offer made to the client %d at a cost of %d.  Average Cost: %f\n", selected_client, cost[product_aux[j]->inf][j], (float)((fcostpo[j] + prod_cost[j]) / sum_offers_p[j]));
							if (sum_offers_p[j] == mcpo[i])
								budget_slack[j] = budgetpo[j] - n->budget[j];

						}
						else if ((prod_cost[j] + cost[product_aux[j]->inf][j]) / (sum_offers_p[j] + 1) <= average_goal && !(n->budget[j] >= cost[product_aux[j]->inf][j]) && i < 0.4*client)
						{

							offer_reserve[i][j] = product_aux[j]->inf;
							offer_reserve[i][j] = product_aux[j]->inf;
							reserve_cost[j] += cost[product_aux[j]->inf][j];
							fprintf(log, "Added an offer made to the client %d at a cost of %d to the reserve.\n", product_aux[j]->inf, cost[product_aux[j]->inf][j]);
							sum_offer_r[j]++;
							i++;
						}
					}
				}
			}
		}
		
		printf("\n");
		for (i = 0; i < prod; i++)
		{
			printf("Budget for product %d: %d. -> ", i, n->budget[i]);
		}
		printf("\n");

		for (j = 0; j < prod; j++)
		{
			prod_index[j] = j;
			sum_profit1[j] = prod_rev[j] - prod_cost[j] - fcostpo[j];
			for (i = 0; i < client; i++)
			{
				if (n->clients[i].offers[j] == 1)
				{
					if (sum_offers_c[i] > maxofer[i])
					{
						conflicts[j]++;
					}
				}
			}
		}
		qsort((void*)prod_index, prod, sizeof(int), compare2);
		int sumoffers[MAXC];

		for (j = 0; j < client; j++)
		{
			sum_offers_c[j] = 0;
		}
		for (i = 0; i < prod; i++)
			blocked_prod[i] = 0;
		solution_cost = 0;
		//Attempt to solve conflicts generated by the client offer limit constraint.
		for (j = 0; j < prod; j++)
		{
			if (sum_offers_p[prod_index[j]] >= mcpo[prod_index[j]])
			{
				if (blocked_prod[prod_index[j]]==0 && resolve_conflicts_GEN(conflict_matrix, n, prod_index[j], prod, client, cost, revenue, fcostpo, maxofer, mcpo, budgetpo, sorted_npp, sum_offers_c, sum_offers_p, sum_offer_r, offer_reserve, reserve_cost, prod_cost, prod_rev, conflicts))
				{
					n->offeredProducts[prod_index[j]] = true;
					if (can1 && prod_can[prod_index[j]] > 0)
						blocked_prod[prod_can[prod_index[j]]] = 1;
					solution_cost += prod_rev[prod_index[j]] - prod_cost[prod_index[j]] - fcostpo[prod_index[j]];
					check_values(n, fcostpo, cost, revenue, n->cost, n->revenue, n->fitness, prod, client);
					
				}
				else
				{
					for (i = 0; i < client; i++)
						n->clients[i].offers[prod_index[j]] = false;
					sum_offers_p[prod_index[j]] = 0;
					n->budget[prod_index[j]] = budgetpo[prod_index[j]];
					prod_cost[prod_index[j]] = 0;
					prod_rev[prod_index[j]] = 0;
					n->offeredProducts[prod_index[j]] = false;

				}
			}
			else
			{
				for (i = 0; i < client; i++)
					n->clients[i].offers[prod_index[j]] = false;
				sum_offers_p[prod_index[j]] = 0;
				n->budget[prod_index[j]] = budgetpo[prod_index[j]];
				prod_cost[prod_index[j]] = 0;
				prod_rev[prod_index[j]] = 0;
				n->offeredProducts[prod_index[j]] = false;
			}
		}


		//Attempts to add aditional offers on the solution resulting from the conflict resolution process.
		for (j = 0; j < prod; j++)
		{
			if (n->offeredProducts[prod_index[j]])
			{
				fprintf(log, "Initiating the completion process for the product %d with a original budget of %d.\n", prod_index[j], n->budget[prod_index[j]]);
				for (product_aux[prod_index[j]] = sorted_npp[prod_index[j]]->prox; product_aux[prod_index[j]] && n->budget[prod_index[j]] >= minimum_cost[prod_index[j]]; product_aux[prod_index[j]] = product_aux[prod_index[j]]->prox)
				{
					if (cost[product_aux[prod_index[j]]->inf][prod_index[j]] <= n->budget[prod_index[j]] && (revenue[product_aux[prod_index[j]]->inf][prod_index[j]]) / (cost[product_aux[prod_index[j]]->inf][prod_index[j]]) >= hurdle && sum_offers_c[product_aux[prod_index[j]]->inf] < maxofer[product_aux[prod_index[j]]->inf] && (n->clients[product_aux[prod_index[j]]->inf].offers[prod_index[j]] < 1))
					{
						n->clients[product_aux[prod_index[j]]->inf].offers[prod_index[j]] = true;
						n->budget[prod_index[j]] -= cost[product_aux[prod_index[j]]->inf][prod_index[j]];
						prod_cost[prod_index[j]] += cost[product_aux[prod_index[j]]->inf][prod_index[j]];
						prod_rev[prod_index[j]] += revenue[product_aux[prod_index[j]]->inf][prod_index[j]];
						sum_offers_p[prod_index[j]]++;
						sum_offers_c[product_aux[prod_index[j]]->inf]++;
						fprintf(log, "New offer to the client %d added with a cost of %d, resulting in a residual budget of budget of %d.\n", product_aux[prod_index[j]]->inf, cost[product_aux[prod_index[j]]->inf][prod_index[j]], n->budget[prod_index[j]]);
					}
				}
			}
			if (sum_offers_p[prod_index[j]] < mcpo[prod_index[j]])
			{
				fprintf(log, "Product %d did not met its minimum offer requirement. (%d/%d)\n", prod_index[j], sum_offers_p[prod_index[j]], mcpo[prod_index[j]]);
				n->offeredProducts[prod_index[j]] = false;
				for (i = 0; i < client; i++)
				{
					n->clients[i].offers[prod_index[j]] = false;
				}
			}
		}
		n->cost = 0;
		n->revenue= 0;
		for (i = 0; i < prod; i++)
		{
			if (n->offeredProducts[i])
			{
				n->cost += fcostpo[i] + prod_cost[i];
				n->revenue += prod_rev[i];
			}
		}
		check_values(n, fcostpo, cost, revenue, n->cost, n->revenue, n->fitness, prod, client);
		printf("\n");
		for (i = 0; i < prod; i++)
		{
			printf("Budget for product %d: %d. -> ", i, n->budget[i]);
		}
		printf("\n");
		fclose(log);
	}
	free(prod_cost);
	free(prod_rev);
	free(budget_slack);
	free(minimum_cost);
	free(average_cost);
	free(sum_offer_r);
	free(conflicts);
	free(sum_offers_p);
	free(sum_offers_c);
	free(finished);
	free(prod_index);
	free(product_aux);
	for (i = 0; i < client*0.7; i++)
		delete[] offer_reserve[i];
	delete[] offer_reserve;
	for (i = 0; i < client; i++)
		delete[] conflict_matrix[i];
	delete[] conflict_matrix;
}

/*Not Utilized*/
void build_initial_solution1(int client, int prod, float hurdle,
	int **cost, int **revenue, int* maxofer,
	int* mcpo, int* budgetpo, int* fcostpo,
	int **solc, int* solp,
	List** sorted_npp, int* active_clients, int* active_products,
	float* sum_cost_fix, float* sum_profit, int* prod_can)
{

	int i, j, cont;
	float **npp; /* profit per product for each client */
	npp = generate_2D_matrix_float(client, prod);
	float aux_revenue, aux_cost, npp_aux;
	int *sum_cost, *sum_revenue, *pr;
	sum_cost = new int[prod];
	sum_revenue = new int[prod];
	pr = new int[prod];
	int max_pr, index_max_pr;
	int search_clients = 1;
	int *allocated_clients;
	allocated_clients = new int[client];
	int *aux_allocated_clients;
	aux_allocated_clients = new int[client];
	int val = 0;
	int exp = 0;
	int *residual_budget;
	int iter_no_offer = 0;
	residual_budget = new int[prod];
	int offers[MAXPROD];


	List* candidates = (List*)malloc(sizeof(List));
	List* aux_list;
	List* pred;

	candidates->prox = NULL;
	for (j = 0; j < prod; j++) {
		residual_budget[j] = budgetpo[j];
	}
	/* computing profit per product for each client */
	for (i = 0; i < client; i++)
	{

		allocated_clients[i] = 0;
		aux_allocated_clients[i] = 0;
		for (j = 0; j < prod; j++)
		{
			aux_revenue = revenue[i][j];
			aux_cost = cost[i][j];
			npp[i][j] = (aux_revenue - aux_cost) / aux_cost;

		}
	}

	/* Building the candidate list */
	for (i = 0; i < client; i++)
	{
		aux_list = candidates;
		while (aux_list->prox != NULL) aux_list = aux_list->prox;
		List* new_c = (List*)malloc(sizeof(List));
		new_c->inf = i;
		new_c->prox = NULL;
		//new_c->ant = NULL;
		aux_list->prox = new_c;
	}

	/* For each product build a non increasing considering profit per product list of clients */
	/* Considering only non offered products and for each of the considering only clients that still can receive offers */

	for (j = 0; j < prod; j++)
	{
		if (active_products[j] != 0)
		{
			aux_list = sorted_npp[j];
			npp_aux = -100000.0;
			for (i = 0; i < client; i++)
			{
				if (active_clients[i] > 0)
				{
					pred = aux_list;
					while ((aux_list->prox != NULL) && (npp_aux > npp[i][j]))
					{
						pred = aux_list;
						aux_list = aux_list->prox;
						npp_aux = npp[aux_list->inf][j];
					}
					if (aux_list->prox == NULL)
					{
						List* new_c = (List*)malloc(sizeof(List));
						new_c->inf = i;
						new_c->prox = NULL;
						aux_list->prox = new_c;
						new_c->ant = NULL;
						aux_list = sorted_npp[j];
						npp_aux = npp[aux_list->prox->inf][j];
					}
					else
					{
						List* new_c = (List*)malloc(sizeof(List));
						new_c->inf = i;
						if (pred == aux_list)
						{
							new_c->prox = aux_list->prox;
							aux_list->prox->ant = new_c;
						}
						else
						{
							new_c->prox = aux_list;
							aux_list->ant = new_c;
						}
						pred->prox = new_c;
						if (pred != sorted_npp[j])
							new_c->ant = pred;
						else
							new_c->ant = NULL;

						aux_list = sorted_npp[j];
						npp_aux = npp[aux_list->prox->inf][j];
					}
				}
			}
		}
	}

	while (search_clients)
	{
		/* Procedure to choose the the product with  the highest profit revenue */
		for (j = 0; j < prod; j++)
		{
			sum_cost[j] = 0;
			sum_revenue[j] = 0;
			pr[j] = 0;
		}
		max_pr = -1;
		index_max_pr = -1;
		for (i = 0; i < client; i++) aux_allocated_clients[i] = 0;
		for (j = 0; j < prod; j++)
		{

			if (active_products[j] != 0)
			{
				aux_list = sorted_npp[j]->prox;
				cont = 0;
				while (aux_list != NULL && cont < mcpo[j] && sum_cost[j] < budgetpo[j])
				{
					if (active_clients[aux_list->inf] > 0 && sum_cost[j] + cost[aux_list->inf][j] <= budgetpo[j])
					{
						sum_cost[j] += cost[aux_list->inf][j];
						sum_revenue[j] += revenue[aux_list->inf][j];
						aux_allocated_clients[cont] = aux_list->inf;
						cont++;
					}
					aux_list = aux_list->prox;
				}
				pr[j] = sum_revenue[j] - sum_cost[j] - fcostpo[j];
				if (pr[j] > max_pr && cont >= mcpo[j])
				{
					max_pr = pr[j];
					index_max_pr = j;
					for (i = 0; i < client; i++) allocated_clients[i] = aux_allocated_clients[i];
				}
				else for (i = 0; i < client; i++) aux_allocated_clients[i] = 0;
				offers[j] = cont;
			}
		}

		if ((index_max_pr >= 0) && (offers[index_max_pr] >= mcpo[index_max_pr]) &&
			(max_pr > 0) &&
			(sum_cost[index_max_pr] <= budgetpo[index_max_pr]) &&
			((val + sum_revenue[index_max_pr]) >= ((1 + hurdle)*(exp + sum_cost[index_max_pr] + fcostpo[index_max_pr]))))
		{
			active_products[index_max_pr] = 0;
			solp[index_max_pr] = 1;
			val = val + sum_revenue[index_max_pr];
			exp = exp + sum_cost[index_max_pr] + fcostpo[index_max_pr];
			for (cont = 0; cont < mcpo[index_max_pr]; cont++)
			{
				solc[allocated_clients[cont]][index_max_pr] = 1;
				residual_budget[index_max_pr] -= cost[allocated_clients[cont]][index_max_pr];
				active_clients[allocated_clients[cont]] -= 1;
			}
			sorted_npp[index_max_pr]->inf = cont;
			if (can1)
			{
				if (prod_can[index_max_pr] >= 0)
				{
					int ii;
					active_products[prod_can[index_max_pr]] = 0;
					/*for (ii = 0; ii < prod; ii++)
					{
						if ((prod_can[ii] == prod_can[index_max_pr]) && (ii != index_max_pr))
							active_products[ii] = 0;
					}
					for (ii = 0; ii < prod; ii++)
						printf("index_max_prod = %d,  active_prod[%d] = %d, prod_can[%d] = %d\n",
							index_max_pr, ii, active_products[ii], ii, prod_can[ii]);*/
				}
			}
		}
		else search_clients = 0;


	}

	/* Allocate the residual clients that make the solution still feasible */

	for (j = 0; j < prod; j++)
	{
		if ((active_products[j] == 0) && (solp[j] == 1))
		{
			for (i = 0; i < client; i++)
			{
				if ((revenue[i][j] > cost[i][j]) && (cost[i][j] <= residual_budget[j]) &&
					(active_clients[i] > 0) && (solc[i][j] == 0) &&
					((val + revenue[i][j]) >= ((1 + hurdle)*(exp + cost[i][j]))))
				{
					residual_budget[j] -= cost[i][j];
					active_clients[i] -= 1;
					sorted_npp[j]->inf += 1;
					solc[i][j] = 1;
					val += revenue[i][j];
					exp += cost[i][j];
				}
			}

		}
	}
	*sum_cost_fix = exp;
	*sum_profit = val;

}
/*Not utilized*/
void build_initial_solution21(int client, int prod, float hurdle,
	int **cost, int **revenue, int* maxofer,
	int* mcpo, int* budgetpo, int* fcostpo,
	int **solc, int* solp,
	List** sorted_npp, int* active_clients, int* active_products,
	float* sum_cost_fix, float* sum_profit, int* prod_can, int iter)
{

	int i, j, cont;
	float **npp; /* profit per product for each client */
	npp = generate_2D_matrix_float(client, prod);
	float aux_revenue, aux_cost, npp_aux;
	int random;
	int *sum_cost, *sum_revenue, *pr;
	sum_cost = new int[prod];
	sum_revenue = new int[prod];
	pr = new int[prod];
	int max_pr, index_max_pr;
	int search_clients = 1;
	int *allocated_clients;
	allocated_clients = new int[client];
	int *aux_allocated_clients;
	aux_allocated_clients = new int[client];
	int *selected_clients;
	selected_clients = new int[client];
	int val = 0;
	int exp = 0;
	int *residual_budget;
	residual_budget = new int[prod];
	int cont2;
	bool flag = false;
	int interval = (int)(client*0.10);
	int last_offer;
	int last_offer_counter;
	int iter_no_offer = 0;
	//List* candidates = (List*)malloc(sizeof(List));
	List* aux_list;
	List* aux_list2;
	List* pred;
	int offers[MAXPROD];

	//candidates->prox = NULL;
	for (j = 0; j < prod; j++) {
		residual_budget[j] = budgetpo[j];
	}
	/* computing profit per product for each client */
	for (i = 0; i < client; i++)
	{

		allocated_clients[i] = 0;
		aux_allocated_clients[i] = 0;
		for (j = 0; j < prod; j++)
		{
			aux_revenue = revenue[i][j];
			aux_cost = cost[i][j];
			npp[i][j] = (aux_revenue - aux_cost) / aux_cost;

		}
	}

	/* Building the candidate list */
	/*for (i = 0; i < client; i++)
	{
		aux_list = candidates;
		while (aux_list->prox != NULL) aux_list = aux_list->prox;
		List* new_c = (List*)malloc(sizeof(List));
		new_c->inf = i;
		new_c->prox = NULL;
		aux_list->prox = new_c;
	}
*/
/* For each product build a non increasing considering profit per product list of clients */
/* Considering only non offered products and for each of the considering only clients that still can receive offers */
	/*for (j = 0; j < prod; j++)
	{
		if (active_products[j] != 0)
		{
			aux_list = sorted_npp[j];
			npp_aux = -100000.0;
			for (i = 0; i < client; i++)
			{
				if (active_clients[i] > 0)
				{
					pred = aux_list;
					while ((aux_list->prox != NULL) && (npp_aux > npp[i][j]))
					{
						pred = aux_list;
						aux_list = aux_list->prox;
						npp_aux = npp[aux_list->inf][j];
					}
					if (aux_list->prox == NULL)
					{
						List* new_c = (List*)malloc(sizeof(List));
						new_c->inf = i;
						new_c->prox = NULL;
						aux_list->prox = new_c;
						new_c->ant = NULL;
						aux_list = sorted_npp[j];
						npp_aux = npp[aux_list->prox->inf][j];
					}
					else
					{
						List* new_c = (List*)malloc(sizeof(List));
						new_c->inf = i;
						if (pred == aux_list)
						{
							new_c->prox = aux_list->prox;
							aux_list->prox->ant = new_c;
						}
						else
						{
							new_c->prox = aux_list;
							aux_list->ant = new_c;
						}
						pred->prox = new_c;
						if (pred != sorted_npp[j])
							new_c->ant = pred;
						else
							new_c->ant = NULL;

						aux_list = sorted_npp[j];
						npp_aux = npp[aux_list->prox->inf][j];
					}
				}
			}
		}
	}*/
	/*for (j = 0; j < prod; j++)
	{
		printf("Prod %d\n", j);
		for (aux_list = sorted_npp[j]; aux_list; aux_list = aux_list->prox)
		{
			printf("%d->", aux_list->inf);
		}
		printf("\n");
	}*/
	for (i = 0; i < client; i++)
		selected_clients[i] = 0;
	// oferta sendo inserida multiplas vezes.
	while (search_clients)
	{
		/* Procedure to choose the the product with  the highest profit revenue */
		for (j = 0; j < prod; j++)
		{
			sum_cost[j] = 0;
			sum_revenue[j] = 0;
			pr[j] = 0;
		}
		max_pr = -1;
		index_max_pr = -1;

		for (j = 0; j < prod; j++)
		{
			//Zerar clientes selecionados aqui
			for (i = 0; i < client; i++)
				selected_clients[i] = 0;
			for (i = 0; i < client; i++) aux_allocated_clients[i] = -1;
			if (active_products[j] != 0)
			{
				aux_list = sorted_npp[j]->prox;
				cont = 0;
				last_offer_counter = 0;
				last_offer = aux_list->inf;
				iter_no_offer = 0;
				//Modificar esse loop por um loop randomizante
				List *aux_list2 = sorted_npp[j];
				while (cont < mcpo[j] && sum_cost[j] < budgetpo[j])
				{
					random = (rand() % interval) + 1;
					flag = false;
					for (aux_list = aux_list2, cont2 = 0; aux_list->prox; aux_list = aux_list->prox)
					{
						if (!(selected_clients[aux_list->inf]) && active_clients[aux_list->inf] > 0)
						{
							if (flag == false)
							{
								flag = true;
								aux_list2 = aux_list;
							}
							cont2++;
						}
						if (cont2 == random) break;
					}
					//Talvez entre num ponto onde nao existem mais ofertas que nao estourem o orcamento, tentando repetir sempre a mesma oferta que vai estourar o orcamento
					if (active_clients[aux_list->inf] > 0 && sum_cost[j] + cost[aux_list->inf][j] <= budgetpo[j] && selected_clients[aux_list->inf] < 1)
					{
						sum_cost[j] += cost[aux_list->inf][j];
						sum_revenue[j] += revenue[aux_list->inf][j];
						aux_allocated_clients[cont] = aux_list->inf;
						cont++;
						selected_clients[aux_list->inf] = 1;
						last_offer = aux_list->inf;
						last_offer_counter = 0;
						iter_no_offer = 0;
					}
					else
					{
						if (aux_list->inf != last_offer)
						{
							last_offer = aux_list->inf;
							last_offer_counter = 0;
						}
						else
						{
							last_offer_counter++;
						}
						iter_no_offer++;
						if (!active_clients[aux_list->inf]) break;
						if (last_offer_counter > 5) break;
						if (iter_no_offer > client*0.10) break;
					}
				}
				offers[j] = cont;
				pr[j] = sum_revenue[j] - sum_cost[j] - fcostpo[j];
				if (pr[j] > max_pr && cont >= mcpo[j])
				{
					max_pr = pr[j];
					index_max_pr = j;
					for (i = 0; i < client; i++) allocated_clients[i] = aux_allocated_clients[i];
				}
				else for (i = 0; i < client; i++) aux_allocated_clients[i] = 0;
			}
		}

		if ((index_max_pr >= 0) && (offers[index_max_pr] >= mcpo[index_max_pr]) &&
			(max_pr > 0) &&
			(sum_cost[index_max_pr] <= budgetpo[index_max_pr]) &&
			((val + sum_revenue[index_max_pr]) >= ((1 + hurdle)*(exp + sum_cost[index_max_pr]))))
		{
			active_products[index_max_pr] = 0;
			solp[index_max_pr] = 1;
			val = val + sum_revenue[index_max_pr];
			exp = exp + sum_cost[index_max_pr] + fcostpo[index_max_pr];
			/*printf("Produto %d:\n", index_max_pr);*/
			for (cont = 0; cont < mcpo[index_max_pr]; cont++)
			{
				/*printf("%d, ", allocated_clients[cont]);*/
				solc[allocated_clients[cont]][index_max_pr] = 1;
				residual_budget[index_max_pr] -= cost[allocated_clients[cont]][index_max_pr];
				active_clients[allocated_clients[cont]] -= 1;
			}
			/*printf("\nOfertas inseridas para o produto %d : %d \n", index_max_pr, cont);*/
			sorted_npp[index_max_pr]->inf = cont;
			if (can1)
			{
				if (prod_can[index_max_pr] >= 0)
				{
					int ii;
					active_products[prod_can[index_max_pr]] = 0;
					/*for (ii = 0; ii < prod; ii++)
					{
						if ((prod_can[ii] == prod_can[index_max_pr]) && (ii != index_max_pr))
							active_products[ii] = 0;
					}
					for (ii = 0; ii < prod; ii++)
						printf("index_max_prod = %d,  active_prod[%d] = %d, prod_can[%d] = %d\n",
							index_max_pr, ii, active_products[ii], ii, prod_can[ii]);*/
				}
			}
		}
		else search_clients = 0;


	}

	/* Allocate the residual clients that make the solution still feasible */
	//Talvez eu precise manter a lista de selecionados
	for (j = 0; j < prod; j++)
	{
		if ((active_products[j] == 0) && (solp[j] == 1))
		{
			for (i = 0; i < client; i++)
			{
				if ((revenue[i][j] > cost[i][j]) && (cost[i][j] <= residual_budget[j]) &&
					(active_clients[i] > 0) && (solc[i][j] == 0) &&
					((val + revenue[i][j]) >= ((1 + hurdle)*(exp + cost[i][j]))))
				{
					residual_budget[j] -= cost[i][j];
					active_clients[i] -= 1;
					sorted_npp[j]->inf += 1;
					solc[i][j] = 1;
					val += revenue[i][j];
					exp += cost[i][j];
				}
			}

		}
	}
	*sum_cost_fix = exp;
	*sum_profit = val;

	delete sum_cost;
	delete sum_revenue;
	delete pr;
	delete allocated_clients;
	delete aux_allocated_clients;
	delete selected_clients;
	delete residual_budget;

}

//Greedy deterministic constructive algorithm. (Nobibon)
void build_initial_solution(int client, int prod, float hurdle,
	int **cost, int **revenue, int* maxofer,
	int* mcpo, int* budgetpo, int* fcostpo,
	int **solc, int* solp,
	List** sorted_npp, int* active_clients, int* active_products,
	float* sum_cost_fix, float* sum_profit, int* prod_can, int *prod_order)
{
	//newpop = true;
	int i, j, cont;
	float **npp; /* profit per product for each client */
	npp = generate_2D_matrix_float(client, prod);
	float aux_revenue, aux_cost, npp_aux;
	int *sum_cost, *sum_revenue, *pr;
	sum_cost = new int[prod];
	sum_revenue = new int[prod];
	pr = new int[prod];
	int max_pr, index_max_pr;
	int search_clients = 1;
	int *allocated_clients;
	allocated_clients = new int[client];
	int *aux_allocated_clients;
	aux_allocated_clients = new int[client];
	int val = 0;
	int exp = 0;
	int *residual_budget;
	int iter_no_offer = 0;
	residual_budget = new int[prod];
	int offers[MAXPROD];


	List* candidates = (List*)malloc(sizeof(List));
	List* aux_list;
	List* pred;

	candidates->prox = NULL;
	for (j = 0; j < prod; j++) {
		residual_budget[j] = budgetpo[j];
		prod_order[j] = 0;
	}
	for (i = 0; i < client; i++)
	{
		active_clients[i] = maxofer[i];
		for (j = 0; j < prod; j++)
		{
			solc[i][j] = 0;
		}
	}
	
	/* computing profit per product for each client */
	for (i = 0; i < client; i++)
	{

		allocated_clients[i] = 0;
		aux_allocated_clients[i] = 0;
		for (j = 0; j < prod; j++)
		{
			aux_revenue = revenue[i][j];
			aux_cost = cost[i][j];
			npp[i][j] = (aux_revenue - aux_cost) / aux_cost;
			prod_order[j] += npp[i][j];
		}
	}
	//Remover
	/* Building the candidate list */
	for (i = 0; i < client; i++)
	{
		aux_list = candidates;
		while (aux_list->prox != NULL) aux_list = aux_list->prox;
		List* new_c = (List*)malloc(sizeof(List));
		new_c->inf = i;
		new_c->prox = NULL;
		//new_c->ant = NULL;
		aux_list->prox = new_c;
	}

	/* For each product build a non increasing considering profit per product list of clients */
	/* Considering only non offered products and for each of the considering only clients that still can receive offers */
	//Remover
	for (j = 0; j < prod; j++)
	{
		if (active_products[j] != 0)
		{
			aux_list = sorted_npp[j];
			npp_aux = -100000.0;
			for (i = 0; i < client; i++)
			{
				if (active_clients[i] > 0)
				{
					pred = aux_list;
					while ((aux_list->prox != NULL) && (npp_aux > npp[i][j]))
					{
						pred = aux_list;
						aux_list = aux_list->prox;
						npp_aux = npp[aux_list->inf][j];
					}
					if (aux_list->prox == NULL)
					{
						List* new_c = (List*)malloc(sizeof(List));
						new_c->inf = i;
						new_c->prox = NULL;
						aux_list->prox = new_c;
						new_c->ant = aux_list;
						aux_list = sorted_npp[j];
						npp_aux = npp[aux_list->prox->inf][j];
					}
					else
					{
						List* new_c = (List*)malloc(sizeof(List));
						new_c->inf = i;
						if (pred == aux_list)
						{
							new_c->prox = aux_list->prox;
							aux_list->prox->ant = new_c;
						}
						else
						{
							new_c->prox = aux_list;
							aux_list->ant = new_c;
						}
						pred->prox = new_c;
						if (pred != sorted_npp[j])
							new_c->ant = pred;
						else
							new_c->ant = NULL;

						aux_list = sorted_npp[j];
						npp_aux = npp[aux_list->prox->inf][j];
					}
				}
			}
		}
	}
	for (j = 0; j < prod; j++)
	{
		for (aux_list = sorted_npp[j]; aux_list->prox; aux_list = aux_list->prox)
		{
		}
		sorted_npp[j]->last = aux_list;
	}
	while (search_clients)
	{
		/* Procedure to choose the the product with  the highest profit revenue */
		for (j = 0; j < prod; j++)
		{
			sum_cost[j] = 0;
			sum_revenue[j] = 0;
			pr[j] = 0;
		}
		max_pr = -1;
		index_max_pr = -1;
		for (i = 0; i < client; i++) aux_allocated_clients[i] = -1;
		for (j = 0; j < prod; j++)
		{

			if (active_products[j] != 0)
			{
				aux_list = sorted_npp[j]->prox;//remover
				cont = 0;
				//for (i = 0; i < 1200; i++) aux_list = aux_list->prox;
				while (aux_list != NULL && cont < mcpo[j] && sum_cost[j] < budgetpo[j])//utilizar vetor ao inves de lista
				{
					if (active_clients[aux_list->inf] > 0 && sum_cost[j] + cost[aux_list->inf][j] <= budgetpo[j])
					{
						sum_cost[j] += cost[aux_list->inf][j];
						sum_revenue[j] += revenue[aux_list->inf][j];
						aux_allocated_clients[cont] = aux_list->inf;
						cont++;
					}
					aux_list = aux_list->prox;
				}
				pr[j] = sum_revenue[j] - sum_cost[j] - fcostpo[j];
				if (pr[j] > max_pr && cont >= mcpo[j])
				{
					max_pr = pr[j];
					index_max_pr = j;
					for (i = 0; i < client; i++) allocated_clients[i] = aux_allocated_clients[i];
				}
				else for (i = 0; i < client; i++) aux_allocated_clients[i] = -1;
				offers[j] = cont;
				//if (offers[j] < mcpo[j])
				//{
				//	heuristic_constructive(client, prod, hurdle, cost, revenue, maxofer, mcpo, budgetpo, fcostpo, aux_allocated_clients, sorted_npp, active_clients, active_products, sum_cost_fix, sum_profit, prod_can, j);//Enviar referencia de vetor ordenado
				//	if (aux_allocated_clients[0] == -1)
				//		continue;
				//	for (i = 0, sum_revenue[j] = 0, sum_cost[j] = 0; i < mcpo[j]; i++)
				//	{
				//		sum_revenue[j] += revenue[aux_allocated_clients[i]][j];
				//		sum_cost[j] += cost[aux_allocated_clients[i]][j];
				//	}
				//	pr[j] = sum_revenue[j] - sum_cost[j] - fcostpo[j];
				//	if (pr[j] > max_pr)
				//	{
				//		max_pr = pr[j];
				//		index_max_pr = j;
				//		for (i = 0; i < client; i++) allocated_clients[i] = aux_allocated_clients[i];
				//	}
				//	else for (i = 0; i < client; i++) aux_allocated_clients[i] = 0;
				//	offers[j] = mcpo[j];
				//}
			}
			
		}

		if ((index_max_pr >= 0) && (offers[index_max_pr] >= mcpo[index_max_pr]) &&
			(max_pr > 0) &&
			(sum_cost[index_max_pr] <= budgetpo[index_max_pr]))
		{
			//&&
				/*((val + sum_revenue[index_max_pr]) >= ((1 + hurdle)*(exp + sum_cost[index_max_pr] + fcostpo[index_max_pr])))*///)
			if ((val + sum_revenue[index_max_pr]) >= ((1 + hurdle)*(exp + sum_cost[index_max_pr] + fcostpo[index_max_pr]))/*true*/)
			{
				active_products[index_max_pr] = 0;
				solp[index_max_pr] = 1;
				val = val + sum_revenue[index_max_pr];
				exp = exp + sum_cost[index_max_pr] + fcostpo[index_max_pr];
				for (cont = 0; allocated_clients[cont] >= 0; cont++)
				{
					solc[allocated_clients[cont]][index_max_pr] = 1;
					residual_budget[index_max_pr] -= cost[allocated_clients[cont]][index_max_pr];
					active_clients[allocated_clients[cont]] -= 1;
				}
				sorted_npp[index_max_pr]->inf = cont;
				if (can1)
				{
					if (prod_can[index_max_pr] >= 0)
					{
						int ii;
						active_products[prod_can[index_max_pr]] = 0;
						/*for (ii = 0; ii < prod; ii++)
						{
							if ((prod_can[ii] == prod_can[index_max_pr]) && (ii != index_max_pr))
								active_products[ii] = 0;
						}
						for (ii = 0; ii < prod; ii++)
							printf("index_max_prod = %d,  active_prod[%d] = %d, prod_can[%d] = %d\n",
								index_max_pr, ii, active_products[ii], ii, prod_can[ii]);*/
					}
				}

			}
			else
			{
				search_clients = 0;
			}
		}
		else search_clients = 0;


	}
	search_clients = 1;
	while (search_clients)
	{
		/* Procedure to choose the the product with  the highest profit revenue */
		for (j = 0; j < prod; j++)
		{
			sum_cost[j] = 0;
			sum_revenue[j] = 0;
			pr[j] = 0;
		}
		max_pr = -1;
		index_max_pr = -1;
		for (i = 0; i < client; i++) aux_allocated_clients[i] = 0;
		for (j = 0; j < prod; j++)
		{

			if (active_products[j] != 0)
			{
				aux_list = sorted_npp[j]->prox;
				cont = 0;
				heuristic_constructive(client, prod, hurdle, cost, revenue, maxofer, mcpo, budgetpo, fcostpo, aux_allocated_clients, sorted_npp, active_clients, active_products, sum_cost_fix, sum_profit,prod_can,j);
				if (aux_allocated_clients[0] == -1)
					continue;
				for (i = 0,sum_revenue[j]=0,sum_cost[j]=0; i < mcpo[j]; i++)
				{
					sum_revenue[j] += revenue[aux_allocated_clients[i]][j];
					sum_cost[j] += cost[aux_allocated_clients[i]][j];
				}
				pr[j] = sum_revenue[j] - sum_cost[j] - fcostpo[j];
				if (pr[j] > max_pr)
				{
					max_pr = pr[j];
					index_max_pr = j;
					for (i = 0; i < client; i++) allocated_clients[i] = aux_allocated_clients[i];
				}
				else for (i = 0; i < client; i++) aux_allocated_clients[i] = 0;
				//offers[j] = cont;
			}
		}

		if ((index_max_pr >= 0) &&
			(max_pr > 0) &&
			(sum_cost[index_max_pr] <= budgetpo[index_max_pr]) &&
			((val + sum_revenue[index_max_pr]) >= ((1 + hurdle)*(exp + sum_cost[index_max_pr] + fcostpo[index_max_pr]))))
		{
			active_products[index_max_pr] = 0;
			solp[index_max_pr] = 1;
			val = val + sum_revenue[index_max_pr];
			exp = exp + sum_cost[index_max_pr] + fcostpo[index_max_pr];
			printf("Ofertas incluidas pelo construtor heuristico para o produto %d", index_max_pr);
			for (cont = 0; cont < mcpo[index_max_pr]; cont++)
			{
				solc[allocated_clients[cont]][index_max_pr] = 1;
				residual_budget[index_max_pr] -= cost[allocated_clients[cont]][index_max_pr];
				active_clients[allocated_clients[cont]] -= 1;
				printf("(%d);",allocated_clients[cont]);
			}
			printf("/n Total de ofertas: %d", cont);
			sorted_npp[index_max_pr]->inf = cont;
			if (can1)
			{
				if (prod_can[index_max_pr] >= 0)
				{
					int ii;
					active_products[prod_can[index_max_pr]] = 0;
					/*for (ii = 0; ii < prod; ii++)
					{
						if ((prod_can[ii] == prod_can[index_max_pr]) && (ii != index_max_pr))
							active_products[ii] = 0;
					}
					for (ii = 0; ii < prod; ii++)
						printf("index_max_prod = %d,  active_prod[%d] = %d, prod_can[%d] = %d\n",
							index_max_pr, ii, active_products[ii], ii, prod_can[ii]);*/
				}
			}
		}
		else search_clients = 0;


	}

	/* Allocate the residual clients that make the solution still feasible */

	for (j = 0; j < prod; j++)
	{
		if ((active_products[j] == 0) && (solp[j] == 1))
		{
			for (i = 0; i < client; i++)
			{
				if ((revenue[i][j] > cost[i][j]) && (cost[i][j] <= residual_budget[j]) &&
					(active_clients[i] > 0) && (solc[i][j] == 0) &&
					((val + revenue[i][j]) >= ((1 + hurdle)*(exp + cost[i][j]))))
				{
					residual_budget[j] -= cost[i][j];
					active_clients[i] -= 1;
					sorted_npp[j]->inf += 1;
					solc[i][j] = 1;
					val += revenue[i][j];
					exp += cost[i][j];
				}
			}

		}
	}
	for (i = 0; i < client; i++)
	{
		delete[] npp[i];
	}
	delete[] npp;
	for (i = 0; i < client; i++)
	{
		if (active_clients[i] > 0)
			printf("Vaga\n");
	}
	*sum_cost_fix = exp;
	*sum_profit = val;

}

//Constructive algorithm that selects products greedly based on their profitability, similarly to the Nobibon constructive. But builds their offer sets utilizing the heuristc_constructive in order to attempt to genered better quality initial solutions.
void build_initial_solution_max_offers(int client, int prod, float hurdle,
	int **cost, int **revenue, int* maxofer,
	int* mcpo, int* budgetpo, int* fcostpo,
	int **solc, int* solp,
	List** sorted_npp, int* active_clients, int* active_products,
	float* sum_cost_fix, float* sum_profit, int* prod_can, int *prod_order)
{
	//newpop = true;
	int i, j, cont;
	float **npp; /* profit per product for each client */
	npp = generate_2D_matrix_float(client, prod);
	float aux_revenue, aux_cost, npp_aux;
	int *sum_cost, *sum_revenue, *pr;
	sum_cost = new int[prod];
	sum_revenue = new int[prod];
	pr = new int[prod];
	int max_pr, index_max_pr;
	int search_clients = 1;
	int *allocated_clients;
	allocated_clients = new int[client];
	int *aux_allocated_clients;
	aux_allocated_clients = new int[client];
	int val = 0;
	int exp = 0;
	int *residual_budget;
	int iter_no_offer = 0;
	residual_budget = new int[prod];
	int offers[MAXPROD];


	List* candidates = (List*)malloc(sizeof(List));
	List* aux_list;
	List* pred;

	candidates->prox = NULL;
	for (j = 0; j < prod; j++) {
		residual_budget[j] = budgetpo[j];
		prod_order[j] = 0;
	}
	for (i = 0; i < client; i++)
	{
		active_clients[i] = maxofer[i];
		for (j = 0; j < prod; j++)
		{
			solc[i][j] = 0;
		}
	}

	/* computing profit per product for each client */
	for (i = 0; i < client; i++)
	{

		allocated_clients[i] = 0;
		aux_allocated_clients[i] = 0;
		for (j = 0; j < prod; j++)
		{
			aux_revenue = revenue[i][j];
			aux_cost = cost[i][j];
			npp[i][j] = (aux_revenue - aux_cost) / aux_cost;
			prod_order[j] += npp[i][j];
		}
	}
	
	while (search_clients)
	{
		/* Procedure to choose the the product with  the highest profit revenue */
		for (j = 0; j < prod; j++)
		{
			sum_cost[j] = 0;
			sum_revenue[j] = 0;
			pr[j] = 0;
		}
		max_pr = -1;
		index_max_pr = -1;
		for (i = 0; i < client; i++) aux_allocated_clients[i] = -1;
		for (j = 0; j < prod; j++)
		{

			if (active_products[j] != 0)
			{
				aux_list = sorted_npp[j]->prox;
				cont = 0;
				while (aux_list != NULL && sum_cost[j] < budgetpo[j])
				{
					if (active_clients[aux_list->inf] > 0 && sum_cost[j] + cost[aux_list->inf][j] <= budgetpo[j])
					{
						sum_cost[j] += cost[aux_list->inf][j];
						sum_revenue[j] += revenue[aux_list->inf][j];
						aux_allocated_clients[cont] = aux_list->inf;
						cont++;
					}
					aux_list = aux_list->prox;
				}
				pr[j] = sum_revenue[j] - sum_cost[j] - fcostpo[j];
				if (pr[j] > max_pr && cont >= mcpo[j])
				{
					max_pr = pr[j];
					index_max_pr = j;
					for (i = 0; i < client; i++) allocated_clients[i] = aux_allocated_clients[i];
				}
				else for (i = 0; i < client; i++) aux_allocated_clients[i] = -1;
				offers[j] = cont;
			}

		}

		if ((index_max_pr >= 0) && (offers[index_max_pr] >= mcpo[index_max_pr]) &&
			(max_pr > 0) &&
			(sum_cost[index_max_pr] <= budgetpo[index_max_pr]))
		{
			if ((val + sum_revenue[index_max_pr]) >= ((1 + hurdle)*(exp + sum_cost[index_max_pr] + fcostpo[index_max_pr])))
			{
				active_products[index_max_pr] = 0;
				solp[index_max_pr] = 1;
				val = val + sum_revenue[index_max_pr];
				exp = exp + sum_cost[index_max_pr] + fcostpo[index_max_pr];
				for (cont = 0; allocated_clients[cont] >= 0; cont++)
				{
					solc[allocated_clients[cont]][index_max_pr] = 1;
					residual_budget[index_max_pr] -= cost[allocated_clients[cont]][index_max_pr];
					active_clients[allocated_clients[cont]] -= 1;
				}
				sorted_npp[index_max_pr]->inf = cont;
				if (can1)
				{
					if (prod_can[index_max_pr] >= 0)
					{
						int ii;
						active_products[prod_can[index_max_pr]] = 0;
					}
				}

			}
			else
			{
				search_clients = 0;
			}
		}
		else search_clients = 0;


	}
	search_clients = 1;
	while (search_clients)
	{
		/* Procedure to choose the the product with  the highest profit revenue */
		for (j = 0; j < prod; j++)
		{
			sum_cost[j] = 0;
			sum_revenue[j] = 0;
			pr[j] = 0;
		}
		max_pr = -1;
		index_max_pr = -1;
		for (i = 0; i < client; i++) aux_allocated_clients[i] = 0;
		for (j = 0; j < prod; j++)
		{

			if (active_products[j] != 0)
			{
				aux_list = sorted_npp[j]->prox;
				cont = 0;
				heuristic_constructive(client, prod, hurdle, cost, revenue, maxofer, mcpo, budgetpo, fcostpo, aux_allocated_clients, sorted_npp, active_clients, active_products, sum_cost_fix, sum_profit, prod_can, j);
				if (aux_allocated_clients[0] == -1)
					continue;
				for (i = 0, sum_revenue[j] = 0, sum_cost[j] = 0; i < mcpo[j]; i++)
				{
					sum_revenue[j] += revenue[aux_allocated_clients[i]][j];
					sum_cost[j] += cost[aux_allocated_clients[i]][j];
				}
				pr[j] = sum_revenue[j] - sum_cost[j] - fcostpo[j];
				if (pr[j] > max_pr)
				{
					max_pr = pr[j];
					index_max_pr = j;
					for (i = 0; i < client; i++) allocated_clients[i] = aux_allocated_clients[i];
				}
				else for (i = 0; i < client; i++) aux_allocated_clients[i] = 0;
			}
		}

		if ((index_max_pr >= 0) &&
			(max_pr > 0) &&
			(sum_cost[index_max_pr] <= budgetpo[index_max_pr]) &&
			((val + sum_revenue[index_max_pr]) >= ((1 + hurdle)*(exp + sum_cost[index_max_pr] + fcostpo[index_max_pr]))))
		{
			active_products[index_max_pr] = 0;
			solp[index_max_pr] = 1;
			val = val + sum_revenue[index_max_pr];
			exp = exp + sum_cost[index_max_pr] + fcostpo[index_max_pr];
			printf("Ofertas incluidas pelo construtor heuristico para o produto %d", index_max_pr);
			for (cont = 0; cont < mcpo[index_max_pr]; cont++)
			{
				solc[allocated_clients[cont]][index_max_pr] = 1;
				residual_budget[index_max_pr] -= cost[allocated_clients[cont]][index_max_pr];
				active_clients[allocated_clients[cont]] -= 1;
				printf("(%d);", allocated_clients[cont]);
			}
			printf("/n Total de ofertas: %d", cont);
			sorted_npp[index_max_pr]->inf = cont;
			if (can1)
			{
				if (prod_can[index_max_pr] >= 0)
				{
					int ii;
					active_products[prod_can[index_max_pr]] = 0;
				}
			}
		}
		else search_clients = 0;


	}

	/* Allocate the residual clients that make the solution still feasible */

	for (j = 0; j < prod; j++)
	{
		if ((active_products[j] == 0) && (solp[j] == 1))
		{
			for (i = 0; i < client; i++)
			{
				if ((revenue[i][j] > cost[i][j]) && (cost[i][j] <= residual_budget[j]) &&
					(active_clients[i] > 0) && (solc[i][j] == 0) &&
					((val + revenue[i][j]) >= ((1 + hurdle)*(exp + cost[i][j]))))
				{
					residual_budget[j] -= cost[i][j];
					active_clients[i] -= 1;
					sorted_npp[j]->inf += 1;
					solc[i][j] = 1;
					val += revenue[i][j];
					exp += cost[i][j];
				}
			}

		}
	}
	for (i = 0; i < client; i++)
	{
		delete[] npp[i];
	}
	delete[] npp;
	for (i = 0; i < client; i++)
	{
		if (active_clients[i] > 0)
			printf("Vaga\n");
	}
	*sum_cost_fix = exp;
	*sum_profit = val;

}

//Computes the solution value and checks if there is any constraints being violated.
void compute_solution_value(int client, int prod, float hurdle,
	int **cost, int **revenue, int* maxofer,
	int* mcpo, int* budgetpo, int* fcostpo,
	int **solc, int* solp, float* solution_cost, int* prod_can, bool mode)

{
	int i, j;
	float cost1, revenue1;
	float cost2[MAXPROD];
	int offers[MAXPROD];
	int offers2[MAXC];
	float hurdle1 = 0;

	for (j = 0; j < prod; j++)
	{
		cost2[j] = 0;
		offers[j] = 0;
	}
	for (i = 0; i < client; i++)
	{
		offers2[i] = 0;
	}
	*solution_cost = 0;
	for (j = 0, cost1 = 0, revenue1 = 0; j < prod; j++)
	{
		/**solution_cost -= fcostpo[j] * solp[j];*/
		
		for (i = 0; i < client; i++)
		{
			if (solc[i][j])
				*solution_cost += ((revenue[i][j] - cost[i][j]));
			if (solc[i][j]>0)
				cost1 += cost[i][j];
			if (solc[i][j]>0)
				cost2[j] += cost[i][j];
			if (solc[i][j]>0)
				revenue1 += revenue[i][j];
			if (solc[i][j]>0)
			{
				offers[j]++;
				offers2[i]++;
			}

		}
		if (offers[j] > 0)
		{
			*solution_cost -= fcostpo[j];
			cost1 += fcostpo[j];
			if (solp[j] < 1)
			{
				*solution_cost = 1;
				//break;
			}
		}
	}
	hurdle1 = revenue1 / cost1;
	if (hurdle1 < hurdle + 1 && mode)
		*solution_cost = 1;
	else
	{
		for (j = 0; j < prod; j++)
		{
			if (cost2[j] > budgetpo[j])
			{
 				*solution_cost = 1;
				break;
			}
			if (offers[j] < mcpo[j] && offers[j]>0)
			{
				*solution_cost = 1;
				break;
			}
		}
	}
	for (i = 0; i < client; i++)
	{
		if (offers2[i] > maxofer[i])
		{
			*solution_cost = 1;
			break;
		}
	}
	i = 0;
	for (; i < prod; i++)
	{
		if (solp[i] && prod_can[i] >= 0 && solp[prod_can[i]] && can1)
		{
			*solution_cost = 1;
		}
	}
}

//Randomized greedy constructive algorithm.
void build_initial_solution2(int client, int prod, float hurdle,
	int **cost, int **revenue, int* maxofer,
	int* mcpo, int* budgetpo, int* fcostpo,
	int **solc, int* solp,
	List** sorted_npp, int* active_clients, int* active_products,
	float* sum_cost_fix, float* sum_profit, int* prod_can, int iter)
{

	int i, j, cont;
	float aux_revenue, aux_cost, npp_aux;
	int random;
	int *sum_cost, *sum_revenue, *pr;
	sum_cost = new int[prod];
	sum_revenue = new int[prod];
	pr = new int[prod];
	int max_pr, index_max_pr;
	int search_clients = 1;
	int *allocated_clients;
	allocated_clients = new int[client];
	int *aux_allocated_clients;
	aux_allocated_clients = new int[client];
	int *selected_clients;
	selected_clients = new int[client];
	int val = 0;
	int exp = 0;
	int *residual_budget;
	residual_budget = new int[prod];
	int cont2;
	bool flag = false;
	int interval = (int)(client*0.10);
	int last_offer;
	int last_offer_counter;
	int iter_no_offer = 0;
	List* aux_list;
	List* aux_list2;
	List* pred;
	int offers[MAXPROD];
	int contador_custo, j1, j2;
	float cost_avrg, cost_trgt, cost_avrg2;

	for (j = 0; j < prod; j++) {
		residual_budget[j] = budgetpo[j];
		solp[j] = 0;
	}
	for (i = 0; i < client; i++)
	{
		selected_clients[i] = 0;
		for (j = 0; j < prod; j++)
		{
			solc[i][j] = 0;
		}
	}
	for (i = 0; i < prod; i++)
	{
		active_clients[i] = maxofer[i];
	}
	while (search_clients)
	{
		/* Procedure to choose the the product with  the highest profit revenue */
		for (j = 0; j < prod; j++)
		{
			sum_cost[j] = 0;
			sum_revenue[j] = 0;
			pr[j] = 0;
		}
		max_pr = -1;
		index_max_pr = -1;

		for (j = 0; j < prod; j++)
		{
			for (i = 0; i < client; i++)
				selected_clients[i] = 0;
			for (i = 0; i < client; i++) aux_allocated_clients[i] = -1;
			if (active_products[j] != 0)
			{
				aux_list = sorted_npp[j]->prox; 
				cont = 0;
				last_offer_counter = 0;
				last_offer = aux_list->inf;
				iter_no_offer = 0;
				List *aux_list2 = sorted_npp[j];
				cost_avrg = 0;
				while (cont < mcpo[j] && sum_cost[j] < budgetpo[j])
				{
					random = (rand() % interval) + 1;
					flag = false;
					for (aux_list = aux_list2, cont2 = 0; aux_list->prox; aux_list = aux_list->prox)
					{
						if (!(selected_clients[aux_list->inf]) && active_clients[aux_list->inf] > 0)
						{
							cost_avrg2 = ((float)(sum_cost[j] + cost[aux_list->inf][j]) / (offers[j] + 1));
							if (cost_avrg2<=cost_avrg || cost_avrg == 0 || cost_avrg2 <= cost_trgt)
							{
								if (flag == false)
								{
									flag = true;
									aux_list2 = aux_list;
								}
								cont2++;
							}
						}
						if (cont2 == random) break;
					}
					if (active_clients[aux_list->inf] > 0 && sum_cost[j] + cost[aux_list->inf][j] <= budgetpo[j] && selected_clients[aux_list->inf] < 1)
					{
						sum_cost[j] += cost[aux_list->inf][j];
						sum_revenue[j] += revenue[aux_list->inf][j];
						aux_allocated_clients[cont] = aux_list->inf;
						cont++;
						selected_clients[aux_list->inf] = 1;
						last_offer = aux_list->inf;
						last_offer_counter = 0;
						iter_no_offer = 0;
					}
					else
					{
						if (aux_list->inf != last_offer)
						{
							last_offer = aux_list->inf;
							last_offer_counter = 0;
						}
						else
						{
							last_offer_counter++;
						}
						iter_no_offer++;
						if (!active_clients[aux_list->inf]) break;
						if (last_offer_counter > 5) break;
						if (iter_no_offer > client*0.10) break;
					}
				}
				offers[j] = cont;

				if (sum_cost[j] + 3 >= budgetpo[j])
				{
					cost_trgt = ((float)budgetpo[j] / mcpo[j]);
					cost_avrg = ((float)sum_cost[j] / cont);
					cont = 0;
					while (cost_avrg > cost_trgt && cont<10)
					{
						for (j1 = 0, contador_custo = 0; j1 < client && aux_allocated_clients[j1] != -1; j1++)
						{
							if (cost[aux_allocated_clients[j1]][j] > cost_trgt)
							{
								for (aux_list = sorted_npp[j]->prox; aux_list->inf != aux_allocated_clients[j1]; aux_list = aux_list->prox);
								contador_custo = cost[aux_allocated_clients[j1]][j];
								j2 = aux_allocated_clients[j1];
								List* initial_node = aux_list;
								for (; aux_list && (cost[aux_list->inf][j] > cost_trgt || !(selected_clients[aux_list->inf] != 1) || !(active_clients[aux_list->inf]>0)) && aux_list->inf != initial_node->inf; aux_list = aux_list->prox);
								if (aux_list->inf == initial_node->inf && !(active_clients[aux_list->inf] > 0))
									aux_list = NULL;
								if (aux_list)
								{
									aux_allocated_clients[j1] = aux_list->inf;
									selected_clients[aux_allocated_clients[j1]] = 1;
									selected_clients[j2] = -1;
									sum_cost[j] += cost[aux_allocated_clients[j1]][j] - cost[j2][j];
									sum_revenue[j] += revenue[aux_allocated_clients[j1]][j] - revenue[j2][j];
								}

							}
						}
						cost_avrg = ((float)sum_cost[j] / offers[j]);
						cont++;
					}
					cont = 0;
					while ((cost_avrg > cost_trgt || offers[j]<mcpo[j]) && cont < 5)
					{
						for (aux_list = sorted_npp[j]->prox; aux_list; aux_list = aux_list->prox)
						{
							cost_avrg2 = ((float)(sum_cost[j] + cost[aux_list->inf][j]) / (offers[j] + 1));
							if ((cost_avrg2 <= cost_avrg || cost_avrg2 <= cost_trgt) && selected_clients[aux_list->inf] != 1 && (sum_cost[j] + cost[aux_list->inf][j] <= budgetpo[j]) && active_clients[aux_list->inf]>0)
							{
								selected_clients[aux_list->inf] = 1;
								sum_cost[j] += cost[aux_list->inf][j];
								sum_revenue[j] += revenue[aux_list->inf][j];
								aux_allocated_clients[offers[j]] = aux_list->inf;
								offers[j]++;
								cost_avrg = cost_avrg2;
							}
						}
						cont++;
					}
					for (aux_list = sorted_npp[j]->prox; aux_list; aux_list = aux_list->prox)
					{
						if ( selected_clients[aux_list->inf] != 1 && (sum_cost[j] + cost[aux_list->inf][j] <= budgetpo[j]) && active_clients[aux_list->inf]>0)
						{
							selected_clients[aux_list->inf] = 1;
							sum_cost[j] += cost[aux_list->inf][j];
							sum_revenue[j] += revenue[aux_list->inf][j];
							aux_allocated_clients[offers[j]] = aux_list->inf;
							offers[j]++;
						}
					}
				}
				pr[j] = sum_revenue[j] - sum_cost[j] - fcostpo[j];
				if (pr[j] > max_pr && offers[j] >= mcpo[j])
				{
					max_pr = pr[j];
					index_max_pr = j;
					for (i = 0; i < client; i++) allocated_clients[i] = aux_allocated_clients[i];
				}
				for (i = 0; i < client; i++) aux_allocated_clients[i] = 0;
			}
		}

		if ((index_max_pr >= 0) && (offers[index_max_pr] >= mcpo[index_max_pr]) &&
			(max_pr > 0) &&
			(sum_cost[index_max_pr] <= budgetpo[index_max_pr]))
		{
			active_products[index_max_pr] = 0;
			solp[index_max_pr] = 1;
			val = val + sum_revenue[index_max_pr];
			exp = exp + sum_cost[index_max_pr] + fcostpo[index_max_pr];
			for (cont = 0; cont < mcpo[index_max_pr]; cont++)
			{
				solc[allocated_clients[cont]][index_max_pr] = 1;
				residual_budget[index_max_pr] -= cost[allocated_clients[cont]][index_max_pr];
				active_clients[allocated_clients[cont]] -= 1;
			}
			sorted_npp[index_max_pr]->inf = cont;
			if (can1)
			{
				if (prod_can[index_max_pr] >= 0)
				{
					int ii;
					active_products[prod_can[index_max_pr]] = 0;
				}
			}
			
		}
		else search_clients = 0;


	}
	search_clients = 1;
	bool valid_prods = true;
	while (search_clients)
	{
		/* Procedure to choose the the product with  the highest profit revenue */
		for (j = 0; j < prod; j++)
		{
			sum_cost[j] = 0;
			sum_revenue[j] = 0;
			pr[j] = 0;
		}
		max_pr = -1000000;
		index_max_pr = -1;
		for (i = 0; i < client; i++) aux_allocated_clients[i] = -1;
		for (j = 0; j < prod; j++)
		{

			if (active_products[j] != 0 && (can1 == 0 || active_products[prod_can[j]] <= 0))
			{
				aux_list = sorted_npp[j]->prox;
				cont = 0;
				heuristic_constructive(client, prod, hurdle, cost, revenue, maxofer, mcpo, budgetpo, fcostpo, aux_allocated_clients, sorted_npp, active_clients, active_products, sum_cost_fix, sum_profit, prod_can, j);
				if (aux_allocated_clients[0] == -1)
					continue;
				for (i = 0, sum_revenue[j] = 0, sum_cost[j] = 0; i<client && aux_allocated_clients[i] != -1; i++)
				{
					sum_revenue[j] += revenue[aux_allocated_clients[i]][j];
					sum_cost[j] += cost[aux_allocated_clients[i]][j];
				}
				pr[j] = sum_revenue[j] - sum_cost[j] - fcostpo[j];
				if (pr[j] > max_pr)
				{
					max_pr = pr[j];
					index_max_pr = j;
					for (i = 0; i < client; i++) allocated_clients[i] = aux_allocated_clients[i];
				}
				else for (i = 0; i < client; i++) aux_allocated_clients[i] = -1;
			}
		}
		printf("Produto %d, Lucro %d, orcamento %d /n", index_max_pr, sum_revenue[index_max_pr] -sum_cost[index_max_pr], budgetpo[index_max_pr]-sum_cost[index_max_pr]);
		if ((index_max_pr >= 0) &&
			(max_pr > 0) &&
			(sum_cost[index_max_pr] <= budgetpo[index_max_pr]))
		{
			active_products[index_max_pr] = 0;
			solp[index_max_pr] = 1;
			val = val + sum_revenue[index_max_pr];
			exp = exp + sum_cost[index_max_pr] + fcostpo[index_max_pr];
			printf("Ofertas incluidas pelo construtor heuristico para o produto %d", index_max_pr);
			for (cont = 0; cont < client && allocated_clients[cont] >=0; cont++)
			{
				solc[allocated_clients[cont]][index_max_pr] = 1;
				residual_budget[index_max_pr] -= cost[allocated_clients[cont]][index_max_pr];
				active_clients[allocated_clients[cont]] -= 1;
				printf("(%d);", allocated_clients[cont]);
			}
			printf("/n Total de ofertas: %d", cont);
			sorted_npp[index_max_pr]->inf = cont;
			if (can1)
			{
				if (prod_can[index_max_pr] >= 0)
				{
					int ii;
					active_products[prod_can[index_max_pr]] = 0;
				}
			}
		}
		else
		{
				search_clients = 0;
		}


	}

	/* Allocate the residual clients that make the solution still feasible */
	for (j = 0; j < prod; j++)
	{
		if ((active_products[j] == 0) && (solp[j] == 1))
		{
			for (i = 0; i < client; i++)
			{
				if ((revenue[i][j] > cost[i][j]) && (cost[i][j] <= residual_budget[j]) &&
					(active_clients[i] > 0) && (solc[i][j] == 0))
				{
					residual_budget[j] -= cost[i][j];
					active_clients[i] -= 1;
					sorted_npp[j]->inf += 1;
					solc[i][j] = 1;
					val += revenue[i][j];
					exp += cost[i][j];
					float solution_cost = 0;
					compute_solution_value(client, prod, hurdle,
					cost, revenue, maxofer,
					mcpo, budgetpo, fcostpo,
					solc, solp, &solution_cost, prod_can,false);
				}
			}

		}
	}
	*sum_cost_fix = exp;
	*sum_profit = val;

	delete sum_cost;
	delete sum_revenue;
	delete pr;
	delete allocated_clients;
	delete aux_allocated_clients;
	delete selected_clients;
	delete residual_budget;

}


/*Not utilized*/
bool mutate_solution(int client, int prod, float hurdle, int blocked_prod,
	int **cost, int **revenue, int* maxofer,
	int* mcpo, int* budgetpo, int* fcostpo,
	int **solc, int* solp,
	List** sorted_npp, int* active_clients, int* active_products,
	float* sum_cost_fix, float* sum_profit, int* prod_can)
{

	int i, j, cont;
	float **npp; /* profit per product for each client */
	npp = generate_2D_matrix_float(client, prod);
	float aux_revenue, aux_cost, npp_aux;
	int *sum_cost, *sum_revenue, *pr;
	sum_cost = new int[prod];
	sum_revenue = new int[prod];
	pr = new int[prod];
	int max_pr, index_max_pr;
	int search_clients = 1;
	int *allocated_clients;
	allocated_clients = new int[client];
	int *aux_allocated_clients;
	aux_allocated_clients = new int[client];
	int val = 0;
	int exp = 0;
	int *residual_budget;
	residual_budget = new int[prod];
	List* aux_list;
	int offers[MAXPROD];
	/*List* candidates = (List*)malloc(sizeof(List));

	List* pred;

	candidates->prox = NULL;*/
	for (j = 0; j < prod; j++) {
		residual_budget[j] = budgetpo[j];
		solp[j] = 0;
		active_products[j] = 1;
	}
	/* computing profit per product for each client */
	for (i = 0; i < client; i++)
	{

		allocated_clients[i] = 0;
		aux_allocated_clients[i] = 0;
		active_clients[i] = maxofer[i];
		for (j = 0; j < prod; j++)
		{
			aux_revenue = revenue[i][j];
			aux_cost = cost[i][j];
			npp[i][j] = (aux_revenue - aux_cost) / aux_cost;
			solc[i][j] = 0;
		}
	}

	/* Building the candidate list */
	/*for (i = 0; i < client; i++)
	{
		aux_list = candidates;
		while (aux_list->prox != NULL) aux_list = aux_list->prox;
		List* new_c = (List*)malloc(sizeof(List));
		new_c->inf = i;
		new_c->prox = NULL;
		aux_list->prox = new_c;
	}*/

	/* For each product build a non increasing considering profit per product list of clients */
	/* Considering only non offered products and for each of the considering only clients that still can receive offers */

	/*for (j = 0; j < prod; j++)
	{
		if (active_products[j] != 0)
		{
			aux_list = sorted_npp[j];
			npp_aux = -100000.0;
			for (i = 0; i < client; i++)
			{
				if (active_clients[i] > 0)
				{
					pred = aux_list;
					while ((aux_list->prox != NULL) && (npp_aux > npp[i][j]))
					{
						pred = aux_list;
						aux_list = aux_list->prox;
						npp_aux = npp[aux_list->inf][j];
					}
					if (aux_list->prox == NULL)
					{
						List* new_c = (List*)malloc(sizeof(List));
						new_c->inf = i;
						new_c->prox = NULL;
						aux_list->prox = new_c;
						aux_list = sorted_npp[j];
						npp_aux = npp[aux_list->prox->inf][j];
					}
					else
					{
						List* new_c = (List*)malloc(sizeof(List));
						new_c->inf = i;
						if (pred == aux_list) new_c->prox = aux_list->prox;
						else new_c->prox = aux_list;
						pred->prox = new_c;
						aux_list = sorted_npp[j];
						npp_aux = npp[aux_list->prox->inf][j];
					}
				}
			}
		}
	}*/

	while (search_clients)
	{
		/* Procedure to choose the the product with  the highest profit revenue */
		for (j = 0; j < prod; j++)
		{
			sum_cost[j] = 0;
			sum_revenue[j] = 0;
			pr[j] = 0;
		}
		max_pr = -1;
		index_max_pr = -1;
		for (i = 0; i < client; i++) aux_allocated_clients[i] = 0;
		for (j = 0; j < prod; j++)
		{

			if (active_products[j] != 0 && j != blocked_prod)
			{
				aux_list = sorted_npp[j]->prox;
				cont = 0;
				while (aux_list != NULL && cont < mcpo[j] && sum_cost[j] <= budgetpo[j])
				{
					if (active_clients[aux_list->inf] > 0)
					{
						sum_cost[j] += cost[aux_list->inf][j];
						sum_revenue[j] += revenue[aux_list->inf][j];
						aux_allocated_clients[cont] = aux_list->inf;
						cont++;
					}
					aux_list = aux_list->prox;
				}
				pr[j] = sum_revenue[j] - sum_cost[j] - fcostpo[j];
				if (pr[j] > max_pr && cont >= mcpo[j])
				{
					max_pr = pr[j];
					index_max_pr = j;
					for (i = 0; i < client; i++) allocated_clients[i] = aux_allocated_clients[i];
				}
				else for (i = 0; i < client; i++) aux_allocated_clients[i] = 0;
			}
			offers[j] = cont;
		}

		if ((index_max_pr >= 0) && (offers[index_max_pr] >= mcpo[index_max_pr]) &&
			(max_pr > 0) &&
			(sum_cost[index_max_pr] <= budgetpo[index_max_pr]) &&
			((val + sum_revenue[index_max_pr]) >= ((1 + hurdle)*(exp + sum_cost[index_max_pr] + fcostpo[index_max_pr]))))
		{
			active_products[index_max_pr] = 0;
			solp[index_max_pr] = 1;
			val = val + sum_revenue[index_max_pr];
			exp = exp + sum_cost[index_max_pr] + fcostpo[index_max_pr];
			for (cont = 0; cont < mcpo[index_max_pr]; cont++)
			{
				solc[allocated_clients[cont]][index_max_pr] = 1;
				residual_budget[index_max_pr] -= cost[allocated_clients[cont]][index_max_pr];
				active_clients[allocated_clients[cont]] -= 1;
			}
			sorted_npp[index_max_pr]->inf = cont;
			if (can1)
			{
				if (prod_can[index_max_pr] >= 0)
				{
					int ii;
					for (ii = 0; ii < prod; ii++)
					{
						if ((prod_can[ii] == prod_can[index_max_pr]) && (ii != index_max_pr))
							active_products[ii] = 0;
					}
					for (ii = 0; ii < prod; ii++)
						printf("index_max_prod = %d,  active_prod[%d] = %d, prod_can[%d] = %d\n",
							index_max_pr, ii, active_products[ii], ii, prod_can[ii]);
				}
			}
		}
		else search_clients = 0;


	}

	

	/* Allocate the residual clients that make the solution still feasible */

	for (j = 0; j < prod; j++)
	{
		if ((active_products[j] == 0) && (solp[j] == 1))
		{
			for (i = 0; i < client; i++)
			{
				if ((revenue[i][j] > cost[i][j]) && (cost[i][j] <= residual_budget[j]) &&
					(active_clients[i] > 0) && (solc[i][j] == 0) &&
					((val + revenue[i][j]) >= ((1 + hurdle)*(exp + cost[i][j]))))
				{
					residual_budget[j] -= cost[i][j];
					active_clients[i] -= 1;
					sorted_npp[j]->inf += 1;
					solc[i][j] = 1;
					val += revenue[i][j];
					exp += cost[i][j];
				}
			}

		}
	}

	for (i = 0; i < client; i++)
	{
		for (j = 0, val=maxofer[i]; j < prod; j++)
		{
			if (solc[i][j] != 0)
			{
				val--;
			}
		}
		if (val != active_clients[i])
		{
			printf("Solucao inconsistente com os clientes ativos.\n");
		}
	}
	*sum_cost_fix = exp;
	*sum_profit = val;
	delete sum_cost;
	delete sum_revenue;
	delete pr;
	delete allocated_clients;
	delete aux_allocated_clients;
	delete residual_budget;
	if (val >= (1 + hurdle)*exp && val > 0)
		return true;
	else
		return false;

}
//Builds an population for the genetic algorithm with an randomized greedy constructive algorithm.
bool build_population(int client, int prod, float hurdle,
	int **cost, int **revenue, int* maxofer,
	int* mcpo, int* budgetpo, int* fcostpo,
	cromo *pop,
	List** sorted_npp, int* prod_can, int popSize, float range, float hurdleTolerance, float penalty, float *average_npp)
{

	int i, j, cont;
	float aux_revenue, aux_cost, npp_aux;
	int random;
	int *sum_cost, *sum_revenue, *pr;
	sum_cost = new int[prod];
	sum_revenue = new int[prod];
	pr = new int[prod];
	int max_pr, index_max_pr;
	int search_clients = 1;
	int *allocated_clients;
	allocated_clients = new int[client];
	int *aux_allocated_clients;
	aux_allocated_clients = new int[client];
	int *selected_clients;
	selected_clients = new int[client];
	int val = 0;
	int exp = 0;
	int *residual_budget;
	residual_budget = new int[prod];
	int cont2;
	bool flag = false;
	int interval = (int)(client*range);
	int last_offer;
	int last_offer_counter;
	int iter_no_offer = 0;
	int c;
	int *active_products = new int[prod];
	float hurdle1;
	int cli_cost, sol_cost, cli_rev, sol_rev;
	bool blockedProd[MAXPROD];
	int cost_counter;
	bool solc[MAXC][MAXPROD];
	bool solp[MAXPROD];
	bool ignored_prod[MAXPROD];
	bool rand_flag;
	int prod_quant;
	int prod_cont;
	int **cli_order = generate_2D_matrix_int(client, prod);
	int counter3 = 0;
	List* aux_list;
	List* aux_list2;
	List* pred;
	cromo *n;
	int prod_cost[MAXPROD];
	int min_cost=INT_MAX;


	for (j = 0; j < prod; j++) {
		residual_budget[j] = budgetpo[j];
		active_products[j] = 1;
	}


	for (j = 0; j < prod; j++)
	{
		for (aux_list = sorted_npp[j]->prox, pred = NULL, i=0; i<client; aux_list = aux_list->prox,i++)
		{
			aux_list->ant = pred;
			cli_order[i][j] = aux_list->inf;
			if (aux_list->prox == NULL)
			{
				sorted_npp[j]->last = aux_list;
			}
			if (cost[aux_list->inf][j] < min_cost)
			{
				min_cost = cost[aux_list->inf][j];
			}
			pred = aux_list;
		}
	}
	for (i = 0; i < prod; i++)
		blockedProd[i] = false;
	for (c = 0, prod_quant = prod; c < popSize; c++)
	{

		if (counter3 = 4 * POPSIZE)
			return false;
		counter3++;
		search_clients = 1;
		exp = 0;
		val = 0;
		pop[c].cost = 0;
		pop[c].revenue = 0;
		pop[c].fitness = 0;
		
		if(c>0)
			for (i = 0; i < prod; i++)
			{
				if (rand() % 100 < 15)
					blockedProd[i] = true;
				else
					blockedProd[i] = false;
			}
		for (i = 0; i < MAXPROD; i++)
			ignored_prod[i] = false;

		for (i = 0; i < client; i++)
			selected_clients[i] = 0;

		for (j = 0; j < prod; j++) {
			residual_budget[j] = budgetpo[j];
			active_products[j] = 1;
			pop[c].offeredProducts[j] = false;
			pop[c].budget[j] = budgetpo[j];
		}
		for (i = 0; i < client; i++)
		{
			pop[c].clients[i].offerSlots = maxofer[i];
			allocated_clients[i] = 0;
			aux_allocated_clients[i] = 0;
			pop[c].clients[i].revenue = 0;
			pop[c].clients[i].cost = 0;
			for (j = 0; j < prod; j++)
			{
				pop[c].clients[i].offers[j] = 0;
			}
		}
		if (c >= (int)(0.95*popSize))
		{
			for (i = 0, cont = 0; i < c; i++)
			{
				for (j = 0; j < prod; j++)
					if (pop[i].offeredProducts[j])
						cont++;
			}
			prod_quant = (float)((float)cont / (float)c) - 1;
		}
		while (search_clients)
		{
			/* Procedure to choose the the product with  the highest profit revenue */
			for (j = 0; j < prod; j++)
			{
				sum_cost[j] = 0;
				sum_revenue[j] = 0;
				pr[j] = 0;
			}
			max_pr = -1;
			index_max_pr = -1;

			for (j = 0, prod_cont = 0; j < prod; j++)
			{
				if (prod_cont > prod_quant)
					break;
				for (i = 0; i < client; i++)
				{
					aux_allocated_clients[i] = 0;
				}
				for (i = 0; i < client; i++)
					selected_clients[i] = 0;
				if (active_products[j] != 0 && !ignored_prod[j] && !blockedProd[j])
				{
					cont = 0;
					last_offer_counter = 0;
					last_offer = cli_order[0][j];
					iter_no_offer = 0;
					rand_flag = true;
					interval = mcpo[j];
					List *aux_list2 = sorted_npp[j]->prox;
					while (cont < mcpo[j] && sum_cost[j] + min_cost < budgetpo[j])
					{
						if (rand_flag)
							random = (rand() % interval) + 1;
						flag = false;
						for (cont2=random; cont2<client; cont2++)
						{
							if (!(selected_clients[cli_order[cont2][j]]) && pop[c].clients[cli_order[cont2][j]].offerSlots > 0 && cost[cli_order[cont2][j]][j]+sum_cost[j] <= budgetpo[j])
								break;
							if (cont2 == client-1)
							{
								cont2 = 0;
							}
							if (cont2 == random - 1)
								break;
						}
						if (pop[c].clients[cli_order[cont2][j]].offerSlots > 0 && sum_cost[j] + cost[cli_order[cont2][j]][j] <= budgetpo[j] && !selected_clients[cli_order[cont2][j]] && pop[c].clients[cli_order[cont2][j]].offers[j] == 0)
						{
							sum_cost[j] += cost[cli_order[cont2][j]][j];
							sum_revenue[j] += revenue[cli_order[cont2][j]][j];
							aux_allocated_clients[cont] = cli_order[cont2][j];
							cont++;
							selected_clients[cli_order[cont2][j]] = 1;
							last_offer = cli_order[cont2][j];
							last_offer_counter = 0;
							iter_no_offer = 0;
						}
						else
						{
							if (cli_order[cont2][j]!= last_offer)
							{
								last_offer = cli_order[cont2][j];
								last_offer_counter = 0;
							}
							else
							{
								last_offer_counter++;
							}
							iter_no_offer++;
							if (!pop[c].clients[cli_order[cont2][j]].offerSlots) break;
							
							if(iter_no_offer > 1)
							{
								break;
							}
						}
					}

					pr[j] = sum_revenue[j] - sum_cost[j] - fcostpo[j];
					if (pr[j] > max_pr && cont >= mcpo[j])
					{
						max_pr = pr[j];
						index_max_pr = j;
						for (i = 0; i < client; i++) allocated_clients[i] = aux_allocated_clients[i];
					}
					else for (i = 0; i < client; i++) aux_allocated_clients[i] = 0;
				}
			}
			if ((index_max_pr >= 0) &&
				(max_pr > 0) &&
				(sum_cost[index_max_pr] <= budgetpo[index_max_pr]))
			{
				prod_cont++;
				active_products[index_max_pr] = 0;
				pop[c].offeredProducts[index_max_pr] = true;
				if (can1)
					ignored_prod[prod_can[index_max_pr]] = true;
				val = val + sum_revenue[index_max_pr];
				pop[c].cost += fcostpo[index_max_pr];
				exp = exp + sum_cost[index_max_pr] + fcostpo[index_max_pr];
				solp[index_max_pr] = true;
				for (cont = 0; cont < mcpo[index_max_pr]; cont++)
				{

					pop[c].clients[allocated_clients[cont]].offers[index_max_pr] = 1;
					pop[c].cost += cost[allocated_clients[cont]][index_max_pr];
					pop[c].revenue += revenue[allocated_clients[cont]][index_max_pr];
					pop[c].clients[allocated_clients[cont]].cost += cost[allocated_clients[cont]][index_max_pr];
					pop[c].clients[allocated_clients[cont]].revenue += revenue[allocated_clients[cont]][index_max_pr];
					residual_budget[index_max_pr] -= cost[allocated_clients[cont]][index_max_pr];
					pop[c].budget[index_max_pr] -= cost[allocated_clients[cont]][index_max_pr];
					pop[c].clients[allocated_clients[cont]].offerSlots -= 1;

				}
				sorted_npp[index_max_pr]->inf = cont;
			}
			else search_clients = 0;


		}
		if (c < 0)
		{
			search_clients = 1;
			bool valid_prods = true;
			while (search_clients)
			{
				for (j = 0; j < prod; j++)
				{
					sum_cost[j] = 0;
					sum_revenue[j] = 0;
					pr[j] = 0;
				}
				max_pr = -1000000;
				index_max_pr = -1;
				/* Procedure to choose the the product with  the highest profit revenue */
				for (i = 0; i < client; i++) aux_allocated_clients[i] = -1;
				for (j = 0; j < prod; j++)
				{

					if (active_products[j] != 0 && (can1 == 0 || ignored_prod[prod_can[j]]==false))
					{
						aux_list = sorted_npp[j]->prox;
						cont = 0;
						heuristic_constructive_GEN(client, prod, hurdle, cost, revenue, maxofer, mcpo, budgetpo, fcostpo, aux_allocated_clients, sorted_npp, &pop[c], pop[c].cost, pop[c].revenue, prod_can, j);
						if (aux_allocated_clients[0] == -1)
							continue;
						for (i = 0, sum_revenue[j] = 0, sum_cost[j] = 0; i < client && aux_allocated_clients[i] != -1; i++)
						{
							sum_revenue[j] += revenue[aux_allocated_clients[i]][j];
							sum_cost[j] += cost[aux_allocated_clients[i]][j];
						}
						pr[j] = sum_revenue[j] - sum_cost[j] - fcostpo[j];
						if (pr[j] > max_pr)
						{
							max_pr = pr[j];
							index_max_pr = j;
							for (i = 0; i < client; i++) allocated_clients[i] = aux_allocated_clients[i];
						}
						else for (i = 0; i < client; i++) aux_allocated_clients[i] = -1;
					}
				}
				printf("Produto %d, Lucro %d, orcamento %d /n", index_max_pr, sum_revenue[index_max_pr] - sum_cost[index_max_pr], budgetpo[index_max_pr] - sum_cost[index_max_pr]);
				if ((index_max_pr >= 0) &&
					(max_pr > 0) &&
					(sum_cost[index_max_pr] <= budgetpo[index_max_pr]))
				{
					prod_cont++;
					active_products[index_max_pr] = 0;
					pop[c].offeredProducts[index_max_pr] = true;
					if (can1)
						ignored_prod[prod_can[index_max_pr]] = true;
					val = val + sum_revenue[index_max_pr];
					pop[c].cost += fcostpo[index_max_pr];
					exp = exp + sum_cost[index_max_pr] + fcostpo[index_max_pr];
					solp[index_max_pr] = true;
					for (cont = 0; cont < mcpo[index_max_pr]; cont++)
					{

						pop[c].clients[allocated_clients[cont]].offers[index_max_pr] = 1;
						pop[c].cost += cost[allocated_clients[cont]][index_max_pr];
						pop[c].revenue += revenue[allocated_clients[cont]][index_max_pr];
						pop[c].clients[allocated_clients[cont]].cost += cost[allocated_clients[cont]][index_max_pr];
						pop[c].clients[allocated_clients[cont]].revenue += revenue[allocated_clients[cont]][index_max_pr];
						residual_budget[index_max_pr] -= cost[allocated_clients[cont]][index_max_pr];
						pop[c].budget[index_max_pr] -= cost[allocated_clients[cont]][index_max_pr];
						pop[c].clients[allocated_clients[cont]].offerSlots -= 1;

					}
					sorted_npp[index_max_pr]->inf = cont;
				}
				else
				{
					search_clients = 0;
				}


			}
		}
		int budgetcounter[MAXPROD];
		for (i = 0; i < prod; i++)
			budgetcounter[i] = 0;
		for (i = 0, sol_cost = 0, sol_rev = 0, cost_counter = 0; i < client; i++)
		{
			sol_cost += pop[c].clients[i].cost;
			sol_rev += pop[c].clients[i].revenue;
			for (j = 0, cli_cost = 0, cli_rev = 0; j < prod; j++)
			{
				if (pop[c].clients[i].offers[j]>0)
				{
					cli_cost += cost[i][j];
					cli_rev += revenue[i][j];
					cost_counter += cost[i][j];
					budgetcounter[j] += cost[i][j];
				}

			}
			if (cli_cost != pop[c].clients[i].cost)
				printf("Custo inconsistente para cliente.\n");
			if (cli_rev != pop[c].clients[i].revenue)
				printf("Lucro inconsistente para cliente.\n");
		}

		for (i = 0; i < prod; i++)
			if (budgetcounter[i] > budgetpo[i])
				printf("Inconsistencia.\n");
		for (i = 0; i < prod; i++)
		{
			if (pop[c].offeredProducts[i])
			{
				cost_counter += fcostpo[i];
				sol_cost += fcostpo[i];
			}
		}
		if (sol_rev < pop[c].revenue)
			printf("Lucro inconsistente para solucao.\n");
		if (sol_cost != pop[c].cost)
			printf("Inconsistencia.\n");
		if (cost_counter != pop[c].cost)
			printf("Inconsistencia.\n");
		/* Allocate the residual clients that make the solution still feasible */
		for (j = 0; j < prod; j++)
		{
			if ((active_products[j] == 0))
			{
				for (i = 0; i < client; i++)
				{
					if ((revenue[i][j] > cost[i][j]) && (cost[i][j] <= residual_budget[j]) &&
						(pop[c].clients[i].offerSlots > 0) && (pop[c].clients[i].offers[j] == 0) &&
						((val + revenue[i][j])/ (exp + cost[i][j]) >= val /(exp)))
					{
						residual_budget[j] -= cost[i][j];
						pop[c].budget[j] -= cost[i][j];
						pop[c].clients[i].offerSlots -= 1;
						sorted_npp[j]->inf += 1;
						pop[c].clients[i].offers[j] = 1;
						pop[c].clients[i].cost += cost[i][j];
						pop[c].clients[i].revenue += revenue[i][j];
						pop[c].cost += cost[i][j];
						pop[c].revenue += revenue[i][j];
						val += revenue[i][j];
						exp += cost[i][j];
					}
				}

			}
		}
		if (val > 0)
		{
			pop[c].fitness = pop[c].revenue - pop[c].cost;
			hurdle1 = pop[c].revenue / pop[c].cost;
			for (j = 0; j < prod; j++) {
				pop[c].budget[j] = residual_budget[j];
			}
		}
		else
		{
			c--;
			continue;
		}

		int offers_c[MAXPROD];
		for (j = 0; j < prod; j++)
		{
			prod_cost[j] = 0;
			offers_c[j] = 0;
		}
		
		for (i = 0, sol_cost = 0, sol_rev = 0, cost_counter = 0; i < client; i++)
		{
			sol_cost += pop[c].clients[i].cost;
			sol_rev += pop[c].clients[i].revenue;
			for (j = 0, cli_cost = 0, cli_rev = 0; j < prod; j++)
			{
				if (pop[c].clients[i].offers[j] > 0)
				{
					cli_cost += cost[i][j];
					cli_rev += revenue[i][j];
					cost_counter += cost[i][j];
					prod_cost[j] += cost[i][j];
					offers_c[j]++;
				}

			}
			if (cli_cost != pop[c].clients[i].cost)
				printf("Custo inconsistente para cliente.\n");
			if (cli_rev != pop[c].clients[i].revenue)
				printf("Lucro inconsistente para cliente.\n");
		}
		for (i = 0; i < prod; i++)
		{
			if (pop[c].offeredProducts[i])
			{
				cost_counter += fcostpo[i];
				sol_cost += fcostpo[i];
			}
		}
		if (sol_rev < pop[c].revenue)
			printf("Lucro inconsistente para solucao.\n");
		if (sol_cost != pop[c].cost)
			printf("Inconsistencia.\n");
		if (cost_counter != pop[c].cost)
			printf("Inconsistencia.\n");
		for (j = 0; j < prod; j++)
		{
			if (prod_cost[j] > budgetpo[j])
				printf("Estourou orcamento.\n");
		}
		printf("Individuo %d. Orcamento:\n", c);
		for (j = 0; j < prod; j++)
		{
			if (offers_c[j] < mcpo[j] && pop[c].offeredProducts[j])
				pop[c].fitness = 0;
			printf("(%d,%d), ",j,budgetpo[j]-prod_cost[j]);
		}
		printf("\n");
	}


	delete sum_cost;
	delete sum_revenue;
	delete pr;
	delete allocated_clients;
	delete aux_allocated_clients;
	delete selected_clients;
	delete residual_budget;

}
//Builds an population for the genetic algorithm with a randomized non greedy algorithm
//Inserts offers at random for the products only trying to obey the problem restrictions.
/*Not utilised*/
void build_population_random(int client, int prod, float hurdle,
	int **cost, int **revenue, int* maxofer,
	int* mcpo, int* budgetpo, int* fcostpo,
	cromo *pop,
	List** sorted_npp, int* prod_can, int popSize, float range, float hurdleTolerance, float penalty, float *average_npp, int initial_position)
{

	int i, j, cont;
	float **npp; /* profit per product for each client */
	npp = generate_2D_matrix_float(client, prod);
	float aux_revenue, aux_cost, npp_aux;
	int random;
	int *sum_cost, *sum_revenue, *pr;
	sum_cost = new int[prod];
	sum_revenue = new int[prod];
	pr = new int[prod];
	int max_pr, index_max_pr;
	int search_clients = 1;
	int *allocated_clients;
	allocated_clients = new int[client];
	int *aux_allocated_clients;
	aux_allocated_clients = new int[client];
	int *selected_clients;
	selected_clients = new int[client];
	int val = 0;
	int exp = 0;
	int *residual_budget;
	residual_budget = new int[prod];
	int cont2;
	bool flag = false;
	int interval = (int)(client*range);
	int last_offer;
	int last_offer_counter;
	int iter_no_offer = 0;
	int c;
	int *active_products = new int[prod];
	float hurdle1;
	int cli_cost, sol_cost, cli_rev, sol_rev;
	//int can1 = 0;
	int blockedProd;
	int cost_counter;
	bool solc[MAXC][MAXPROD];
	bool solp[MAXPROD];
	bool ignored_prod[MAXPROD];
	bool rand_flag;
	int prod_quant;
	int prod_cont;
	float slot_average, quota_average;
	List *ofertas = (List*)malloc(sizeof(List)*(client*prod));
	//**trocar manipulacao da matriz cliente/produto para manipulacao do cromossomo mat[i][j] = c->clients[i]->offers[j]
	//**Modificar checagem de hurdle, nao aceitar que o hurdle fique abaixo de 0 mas aceitar os outros
	//**Talvez seja melhor ajustar o hurdle por um parametro de distancia do hurdle exigido (hurdle checado = hurdle exigido-distancia)
	//**Botar um parametro para intervalo da variacao do guloso aleatoriezado para a funcao
	//**Adicionar o custo fixo nos cromossomos do genetico
	//List* candidates = (List*)malloc(sizeof(List));
	//Tentar fazer uma copia de lista de npp para servir como fila aleatoria, todos os elementos da copia vao estar arranjados em um vetor para facilitar reconstrucao
	//Remover elementos selecionados e adiciona-los a uma outra lista de elementos selecionados
	//Em ultimo caso, criar um matriz de solucao tradicional e espelhar as atribuicoes que estao sendo feitas pelo construitivo, no final,  com parar as ofertas na matriz com as ofertas do cromossomo para ver se existem discrepancias
	List* aux_list;
	List* aux_list2;
	List* pred;
	cromo *n;
	int prod_cost[MAXPROD];

	//**** Verificar se o ajuste de custo e renda esta sendo feito corretamente na local_search
	//Tambem verificar se o ajuste do fitness esta sendo feito corretamente pois o local search esta resultando em solucoes inconsistentes

	//candidates->prox = NULL

	for (j = 0, quota_average = 0; j < prod; j++) {
		residual_budget[j] = budgetpo[j];
		active_products[j] = 1;
		quota_average += mcpo[j];
	}
	quota_average = quota_average / prod;
	/* computing profit per product for each client */
	//Mudar isso para resetar cada cromossomo
	for (i = 0, slot_average = 0; i < client; i++)
	{

		allocated_clients[i] = 0;
		aux_allocated_clients[i] = 0;
		slot_average += maxofer[i];
		for (j = 0; j < prod; j++)
		{
			aux_revenue = revenue[i][j];
			aux_cost = cost[i][j];
			npp[i][j] = (aux_revenue - aux_cost) / aux_cost;

		}
	}
	slot_average = slot_average / client;

	/* Building the candidate list */
	/*for (i = 0; i < client; i++)
	{
	aux_list = candidates;
	while (aux_list->prox != NULL) aux_list = aux_list->prox;
	List* new_c = (List*)malloc(sizeof(List));
	new_c->inf = i;
	new_c->prox = NULL;
	aux_list->prox = new_c;
	}
	*/


	/* For each product build a non increasing considering profit per product list of clients */
	/* Considering only non offered products and for each of the considering only clients that still can receive offers */
	//for (j = 0; j < prod; j++)
	//{
	//	aux_list = sorted_npp[j];
	//	npp_aux = -100000.0;
	//	average_npp[j] = 0;
	//	for (i = 0; i < client; i++)
	//	{
	//		pred = aux_list;
	//		while ((aux_list->prox != NULL) && (npp_aux > npp[i][j]))
	//		{
	//			pred = aux_list;
	//			aux_list = aux_list->prox;
	//			npp_aux = npp[aux_list->inf][j];
	//		}
	//		if (aux_list->prox == NULL)
	//		{
	//			List* new_c = (List*)malloc(sizeof(List));
	//			new_c->inf = i;
	//			new_c->prox = NULL;
	//			aux_list->prox = new_c;
	//			new_c->ant = aux_list;
	//			sorted_npp[j]->last = new_c;
	//			//ofertas[j][i] = new_c;
	//			aux_list = sorted_npp[j];
	//			npp_aux = npp[aux_list->prox->inf][j];
	//		}
	//		else
	//		{
	//			List* new_c = (List*)malloc(sizeof(List));
	//			new_c->inf = i;
	//			if (pred == aux_list)
	//			{
	//				new_c->prox = aux_list->prox;
	//				new_c->ant = aux_list;
	//			}
	//			else new_c->prox = aux_list;
	//			pred->prox = new_c;
	//			new_c->ant = pred;
	//			aux_list = sorted_npp[j];
	//			//ofertas[j][i] = new_c;
	//			npp_aux = npp[aux_list->prox->inf][j];
	//		}
	//		if (cost[j][i])
	//			average_npp[j] += (float)(revenue[j][i] / cost[j][i]);
	//	}
	//	average_npp[j] = average_npp[j] / client;
	//}

	//for (j = 0; j < prod; j++)
	//{
	//	for (aux_list = sorted_npp[j]->prox, pred = NULL; aux_list; aux_list = aux_list->prox)
	//	{
	//		aux_list->ant = pred;
	//		if (aux_list->prox == NULL)
	//		{
	//			sorted_npp[j]->last = aux_list;
	//		}
	//		pred = aux_list;
	//	}
	//}
	//printf("\n");
	for (j = 0; j < prod; j++)
	{
		for (i = 0; i < client - 1; i++)
		{

			ofertas[i + j * client].inf = i;
			ofertas[i + j * client].prox = &ofertas[i + 1 + j * client];
			//printf("%d ->", ofertas[i + j * client].inf);
		}
		ofertas[client - 1 + j * client].inf = client - 1;
		ofertas[client - 1 + j * client].prox = NULL;
		//printf("\n");
	}
	//for (j = 0; j < prod; j++)
	//{
	//	for (aux_list = &ofertas[j*client], pred = NULL, i = 0; aux_list; aux_list = aux_list->prox, i++)
	//	{
	//		printf("%d ->", aux_list->inf);
	//		/*aux_list->pred = pred;
	//		pred = aux_list;*/
	//		//ofertas[j][i] = aux_list;
	//	}
	//	printf("\n");
	//}
	int prod_number = (client*slot_average) / quota_average;

	/*build_population(client, prod, hurdle,
		cost, revenue, maxofer,
		mcpo, budgetpo, fcostpo,
		pop,
		sorted_npp, prod_can, (int)(popSize / 5), range, hurdleTolerance, penalty, average_npp);*/
	//int prod_cont;
	//Iniciar o loop para cada individuo aqui mas botar a inicializacao dos valores de cromossomos para baixo
	for (c = initial_position-1, blockedProd = 5, prod_quant = prod, prod_cont = 0; c < popSize; c++, blockedProd++)
	{

		//n = &pop[c];
		search_clients = 1;
		exp = 0;
		val = 0;
		pop[c].cost = 0;
		pop[c].revenue = 0;
		pop[c].fitness = 0;
		for (i = 0; i < client; i++)
			for (j = 0; j < prod; j++)
				solc[i][j] = false;
		for (j = 0; j < prod; j++)
		{
			for (i = 0; i < client - 1; i++)
			{
				ofertas[i + j * client].prox = &ofertas[i + 1 + j * client];
			}
			ofertas[i + j * client].prox = NULL;
		}
		if (blockedProd > prod)
		{
			blockedProd = 0;
		}
		for (i = 0; i < MAXPROD; i++)
			ignored_prod[i] = false;

		for (i = 0; i < client; i++)
			selected_clients[i] = 0;

		for (j = 0; j < prod; j++) {
			residual_budget[j] = budgetpo[j];
			active_products[j] = 1;
			solp[j] = false;
		}
		for (i = 0; i < client; i++)
		{
			pop[c].clients[i].offerSlots = maxofer[i];
			allocated_clients[i] = 0;
			aux_allocated_clients[i] = 0;
			for (j = 0; j < prod; j++)
				pop[c].clients[i].offers[j] = 0;
		}
		if (c >= (int)(0.95*popSize))
		{
			for (i = 0, cont = 0; i < c; i++)
			{
				for (j = 0; j < prod; j++)
					if (pop[i].offeredProducts[j])
						cont++;
			}
		}
		prod_quant = prod_number;
		List *start = NULL;
		int failed_loop = 0;
		//Problema estava no bloquei de produtos que por alguma razao esta afetando o custo.
		while (search_clients)
		{
			/* Procedure to choose the the product with  the highest profit revenue */
			for (j = 0; j < prod; j++)
			{
				sum_cost[j] = 0;
				sum_revenue[j] = 0;
				pr[j] = 0;
			}
			max_pr = -1;
			index_max_pr = -1;

			for (j = 0; j < prod; j++)
			{
				if (active_products[j])
				{
					for (i = 0; i < client - 1; i++)
					{
						ofertas[i + j * client].prox = &ofertas[i + 1 + j * client];
					}
					ofertas[i + j * client].prox = NULL;
				}
			}
			for (j = 0, prod_cont = 0; j < prod; j++)
			{
				/*if (j == blockedProd)
				{
					if (j == prod - 1)
						break;
					else
						j++;
				}*/
				if (prod_cont > prod_quant)
					break;
				//Zerar clientes selecionados aqui
				for (i = 0; i < client; i++)
				{
					aux_allocated_clients[i] = 0;
					//allocated_clients[i] = 0;
				}
				for (i = 0; i < client; i++)
					selected_clients[i] = 0;
				if (active_products[j] != 0 && !ignored_prod[j] && blockedProd != j)
				{
					aux_list = sorted_npp[j]->prox;
					cont = 0;
					last_offer_counter = 0;
					last_offer = aux_list->inf;
					iter_no_offer = 0;
					rand_flag = true;
					//Modificar esse loop por um loop randomizante
					//Randomizar completamente a partir daqui, a lista de clientes e selected_clients[], criar uma lista encadeada de ofertas para randomizacao
					List *aux_list2 = &ofertas[j*client];
					start = aux_list2;
					List *aux_pred = NULL;
					while (cont < client && sum_cost[j] < budgetpo[j])
					{
						if (rand_flag)
							random = (int)((rand() % (client - cont)) + 1);
						flag = false;
						//Tenho que lidar com clientes sem offerslots, remover eles da lista incialmente e mudar para um contador simples com cont2 *****
						for (aux_pred = NULL, aux_list = start, cont2 = 0; aux_list; aux_list = aux_list->prox)
						{
							//printf("%d ->", aux_list->inf);
							cont2++;
							if (cont2 == random)
							{
								//remover oferta da lista
								break;
							}
							aux_pred = aux_list;
						}
						//printf("\n");
						if (aux_list == NULL)
							break;
						if (sum_cost[j] + cost[aux_list->inf][j] > budgetpo[j])
							break;
						//Talvez entre num ponto onde nao existem mais ofertas que nao estourem o orcamento, tentando repetir sempre a mesma oferta que vai estourar o orcamento
						//**Os offerslots nao estavam sendo testados oque possibilitava offerslots atigir valores negativos devido ao fato do aleatoriezador nao um cliente apropriado
						if (pop[c].clients[aux_list->inf].offerSlots > 0 && sum_cost[j] + cost[aux_list->inf][j] <= budgetpo[j] && pop[c].clients[aux_list->inf].offers[j] == 0 && !selected_clients[aux_list->inf])
						{
							sum_cost[j] += cost[aux_list->inf][j];
							sum_revenue[j] += revenue[aux_list->inf][j];
							aux_allocated_clients[cont] = aux_list->inf;
							//printf("Oferta %d : %d \n", cont, aux_list->inf);
							//Ofertas sendo repetidas, possivelmente oriundas do start, checar*****
							cont++;
							selected_clients[aux_list->inf] = 1;
							last_offer = aux_list->inf;
							last_offer_counter = 0;
							iter_no_offer = 0;
							if (aux_list == start)
							{
								start = start->prox;
							}
							else
							{
								aux_pred->prox = aux_list->prox;
							}
						}
						else
						{
							iter_no_offer++;
							if (iter_no_offer > client*0.10)
								break;
						}
					}
					pr[j] = sum_revenue[j] - sum_cost[j] - fcostpo[j];
					if (pr[j] > max_pr && cont >= mcpo[j])
					{
						max_pr = pr[j];
						index_max_pr = j;
						for (i = 0; i < client; i++) allocated_clients[i] = aux_allocated_clients[i];
					}
					else for (i = 0; i < client; i++) aux_allocated_clients[i] = 0;
				}
			}
			//**Inconsistencia no calculo de clientes, refazer a insercao do 0 para tentar concertar
			if (index_max_pr < 0)
			{
				if (failed_loop == 0) failed_loop++;
				else
					search_clients = 0;
			}
			if ((index_max_pr >= 0) &&
				(max_pr > 0) &&
				(sum_cost[index_max_pr] <= budgetpo[index_max_pr]) &&
				((val + sum_revenue[index_max_pr]) >= ((1 + hurdle - hurdleTolerance)*(exp + sum_cost[index_max_pr] + fcostpo[index_max_pr]))))
			{
				prod_cont++;
				active_products[index_max_pr] = 0;
				pop[c].offeredProducts[index_max_pr] = true;
				if (can1)
					ignored_prod[prod_can[index_max_pr]] = true;
				val = val + sum_revenue[index_max_pr];
				pop[c].cost += fcostpo[index_max_pr];
				exp = exp + sum_cost[index_max_pr] + fcostpo[index_max_pr];
				solp[index_max_pr] = true;
				for (cont = 0; cont < mcpo[index_max_pr]; cont++)
				{
					/*if (selected_clients[cont] == 1)
					{*/

					pop[c].clients[allocated_clients[cont]].offers[index_max_pr] = 1;
					solc[allocated_clients[cont]][index_max_pr] = true;
					pop[c].cost += cost[allocated_clients[cont]][index_max_pr];
					pop[c].revenue += revenue[allocated_clients[cont]][index_max_pr];
					pop[c].clients[allocated_clients[cont]].cost += cost[allocated_clients[cont]][index_max_pr];
					pop[c].clients[allocated_clients[cont]].revenue += revenue[allocated_clients[cont]][index_max_pr];
					residual_budget[index_max_pr] -= cost[allocated_clients[cont]][index_max_pr];
					pop[c].budget[index_max_pr] -= cost[allocated_clients[cont]][index_max_pr];
					pop[c].clients[allocated_clients[cont]].offerSlots -= 1;

					/*	}*/
				}
				sorted_npp[index_max_pr]->inf = cont;
				/*if (can1)
				{
					if (prod_can[index_max_pr] >= 0)
					{
						int ii;
						for (ii = 0; ii < prod; ii++)
						{
							if ((prod_can[ii] == prod_can[index_max_pr]) && (ii != index_max_pr))
								active_products[ii] = 0;
						}
						for (ii = 0; ii < prod; ii++)
							printf("index_max_prod = %d,  active_prod[%d] = %d, prod_can[%d] = %d\n",
								index_max_pr, ii, active_products[ii], ii, prod_can[ii]);
					}
				}*/
			}
			else search_clients = 0;


		}
		//pop[c].offeredProducts[blockedProd] = false;
		int budgetcounter[MAXPROD];
		for (i = 0; i < prod; i++)
			budgetcounter[i] = 0;
		for (i = 0, sol_cost = 0, sol_rev = 0, cost_counter = 0; i < client; i++)
		{
			sol_cost += pop[c].clients[i].cost;
			sol_rev += pop[c].clients[i].revenue;
			for (j = 0, cli_cost = 0, cli_rev = 0; j < prod; j++)
			{
				if (pop[c].clients[i].offers[j])
				{
					cli_cost += cost[i][j];
					cli_rev += revenue[i][j];
					cost_counter += cost[i][j];
					budgetcounter[j] += cost[i][j];
					/*if (!solc[i][j])
						printf("Diferenca\n");*/
						//offers[j] += cost[i][j];
						//printf("Prod: %d  Revenue: %d  Cost: %d\n", j, revenue[i][j], cost[i][j]);
				}

			}
			if (cli_cost != pop[c].clients[i].cost)
				printf("Custo inconsistente para cliente.\n");
			if (cli_rev != pop[c].clients[i].revenue)
				printf("Lucro inconsistente para cliente.\n");
		}

		for (i = 0; i < prod; i++)
			if (budgetcounter[i] > budgetpo[i])
				printf("Inconsistencia.\n");
		for (i = 0; i < prod; i++)
		{
			if (pop[c].offeredProducts[i])
			{
				cost_counter += fcostpo[i];
				sol_cost += fcostpo[i];
			}
		}
		/*pop[c].cost = cost_counter;
		pop[c].fitness = pop[c].cost - pop[c].revenue;*/
		if (sol_rev < pop[c].revenue)
			printf("Lucro inconsistente para solucao.\n");
		//if (pop[c].revenue == 0)
		//	printf("Sol Nular\n");
		if (sol_cost != pop[c].cost)
			printf("Inconsistencia.\n");
		if (cost_counter != pop[c].cost)
			printf("Inconsistencia.\n");

		/* Allocate the residual clients that make the solution still feasible */
		//Talvez eu precise manter a lista de selecionados
		for (j = 0; j < prod; j++)
		{
			if ((active_products[j] == 0))
			{
				for (i = 0; i < client; i++)
				{
					if ((revenue[i][j] > cost[i][j]) && (cost[i][j] <= residual_budget[j]) &&
						(pop[c].clients[i].offerSlots > 0) && (pop[c].clients[i].offers[j] == 0))
					{
						residual_budget[j] -= cost[i][j];
						pop[c].budget[j] -= cost[i][j];
						pop[c].clients[i].offerSlots -= 1;
						sorted_npp[j]->inf += 1;
						pop[c].clients[i].offers[j] = 1;
						solc[i][j] = true;
						pop[c].clients[i].cost += cost[i][j];
						pop[c].clients[i].revenue += revenue[i][j];
						pop[c].cost += cost[i][j];
						pop[c].revenue += revenue[i][j];
						val += revenue[i][j];
						exp += cost[i][j];
					}
				}

			}
		}
		if (val > 0)
		{
			/*pop[c].cost = exp;
			pop[c].revenue = val;*/
			/*for (i = 0;i < prod;i++)
				if (active_products[i]==0)
					pop[c].cost += fcostpo[i];*/
			pop[c].fitness = pop[c].revenue - pop[c].cost;
			hurdle1 = pop[c].revenue / pop[c].cost;
			/*if (hurdle1 < 1+hurdle)
			{
				i = (int)(hurdle1 * 100);
				j = i % ((int)(hurdle * 100));
				pop[c].fitness = pop[c].fitness*(1.00 - (penalty*j));
			}*/
			for (j = 0; j < prod; j++) {
				pop[c].budget[j] = residual_budget[j];
			}
		}
		else
		{
			/*printf("Anulo\n");*/
			c--;
		}
		/*for (i = 0;i < prod;i++)
		{
			if (active_products[i])
				pop[c].offeredProducts[i] = false;
			else
				pop[c].offeredProducts[i] = true;
		}*/
		for (j = 0; j < prod; j++)
			prod_cost[j] = 0;
		for (i = 0, sol_cost = 0, sol_rev = 0, cost_counter = 0; i < client; i++)
		{
			sol_cost += pop[c].clients[i].cost;
			sol_rev += pop[c].clients[i].revenue;
			for (j = 0, cli_cost = 0, cli_rev = 0; j < prod; j++)
			{
				if (pop[c].clients[i].offers[j] > 0)
				{
					cli_cost += cost[i][j];
					cli_rev += revenue[i][j];
					cost_counter += cost[i][j];
					prod_cost[j] += cost[i][j];
					//if (!solc[i][j])
					//	printf("Diferenca\n");
					//offers[j] += cost[i][j];
					//printf("Prod: %d  Revenue: %d  Cost: %d\n", j, revenue[i][j], cost[i][j]);
				}

			}
			if (cli_cost != pop[c].clients[i].cost)
				printf("Custo inconsistente para cliente.\n");
			if (cli_rev != pop[c].clients[i].revenue)
				printf("Lucro inconsistente para cliente.\n");
		}
		for (i = 0; i < prod; i++)
		{
			if (pop[c].offeredProducts[i])
			{
				cost_counter += fcostpo[i];
				sol_cost += fcostpo[i];
			}
		}
	
		/*pop[c].cost = cost_counter;
		pop[c].fitness = pop[c].cost - pop[c].revenue;*/
		if (sol_rev < pop[c].revenue)
			printf("Lucro inconsistente para solucao.\n");
		//if (pop[c].revenue == 0)
		//	printf("Sol Nular\n");
		if (sol_cost != pop[c].cost)
			printf("Inconsistencia.\n");
		if (cost_counter != pop[c].cost)
			printf("Inconsistencia.\n");
		for (j = 0; j < prod; j++)
		{
			if (prod_cost[j] > budgetpo[j])
				printf("Estourou orcamento.\n");
			if (pop[c].offeredProducts[j] && prod_can[j] >= 0 && pop[c].offeredProducts[prod_can[j]])
				printf("Canibais pertencentes a mesma solucao.\n");
		}
		//incluir penalidade
	}
	//problema na instancia S1-10-10-1-s-CAN, dois pares canibais envolvendo um mesmo produto.

	free(ofertas);
	delete sum_cost;
	delete sum_revenue;
	delete pr;
	delete allocated_clients;
	delete aux_allocated_clients;
	delete selected_clients;
	delete residual_budget;

}

/*Verfies corrects of the solution*/
int verify_solution(cromo *sol, int *obudget, int prod,int cli, int	**cost, int **revenue, int *mcpo, int *maxoffer,int *prod_can)
{
	int budget[50], cost_[50],revenue_[50], num_offer[50],i,j, cli_offer, profit;
	for (j = 0; j < prod; j++)
	{
		budget[j] = obudget[j];
		cost_[j] = 0;
		revenue_[j] = 0;
		num_offer[j] = 0;
		/*if (prod_can[j] > 0 && can1)
			if (sol->offeredProducts[prod_can[j]] && sol->offeredProducts[j])
				printf("Dupla canibal ofertada simultaneamente.\n");*/
	}
	for (i = 0; i < cli; i++)
	{
		cli_offer = 0;
		for (j = 0; j < prod; j++)
		{
			if (sol->clients[i].offers[j] > 0)
			{
				cost_[j] += cost[i][j];
				budget[j] -= cost[i][j];
				revenue_[j] += revenue[i][j];
				num_offer[j]++;
				cli_offer++;
				if (!sol->offeredProducts[j])
					printf("Offers made to a product outside of the solution.\n");
			}
		}
		if (cli_offer > maxoffer[i])
			printf("Limite de ofertas estourado para cliente %d.\n", i);
	}
	for (j = 0; j < prod; j++)
	{
		if (budget[j] < 0)
			printf("Orcamento estourado.\n");
		if (sol->offeredProducts[j] && num_offer[j] < mcpo[j])
			printf("Produto abaixo do numero de ofertas.\n");
	}
	for (profit = 0, j = 0; j < prod; j++)
	{
		profit += revenue[j] - cost[j];
	}
	return profit;
}

/*Check if budget constrains are being obeyed.*/
bool check_budget(cromo *sol, int *oBuget, int **cost, int prod, int cli)
{
	int i, j, b[50];

	for (j = 0; j < prod; j++)
	{
		b[j] = oBuget[j];
	}

	for (i = 0; i < cli; i++)
	{
		for (j = 0; j < prod; j++)
		{
			if (sol->clients[i].offers[j] > 0)
			{
				b[j] -= cost[i][j];
			}
		}
	}

	for (j = 0; j < prod; j++)
	{
		if (b[j] != sol->budget[j])
			return false;

		if (b[j] < 0)
			return false;
	}

}
/*Check if budget constrains are being obeyed.*/
bool check_budget(int **sol, int *oBuget, int *budget, int **cost, int prod, int cli)
{
	int i, j, b[50];

	for (j = 0; j < prod; j++)
	{
		b[j] = oBuget[j];
	}

	for (i = 0; i < cli; i++)
	{
		for (j = 0; j < prod; j++)
		{
			if (sol[i][j] > 0)
			{
				b[j] -= cost[i][j];
			}
		}
	}

	for (j = 0; j < prod; j++)
	{
		if (b[j] != budget[j])
			return false;

		if (b[j] < 0)
			return false;
	}
}

/*Checks if the cost was correctly calculated*/
bool check_values(cromo *sol, int *fcpo, int** cost, int **revenue, int sum_cost, int sum_revenue, int total_cost, int prod, int cli)
{
	int i, j,sum_c, sum_r;


	for (i = 0, sum_c=0, sum_r=0; i < cli; i++)
	{
		for (j = 0; j < prod; j++)
		{
			if (sol->clients[i].offers[j])
			{
				sum_c += cost[i][j];
				sum_r += revenue[i][j];
			}
		}
	}
	for (j = 0; j < prod; j++)
	{
		if (sol->offeredProducts[j])
		{
			sum_c += fcpo[j];
		}
	}
	if (sum_cost != sum_c)
	{
		return false;
	}
	if (sum_revenue != sum_r)
		return false;
	if (total_cost !=0 && total_cost != sum_r - sum_c)
		return false;
}
/*Checks if the cost was correctly calculated*/
bool check_values2(int **sol, int *solp, int *fcpo, int** cost, int **revenue, int *sum_cost, int *sum_revenue, int total_cost, int prod, int cli)
{
	int i, j, sum_c[MAXPROD], sum_r[MAXPROD];

	for (i = 0; i < prod; i++)
	{
		sum_c[i] = 0;
		sum_r[i] = 0;
	}
	for (i = 0; i < cli; i++)
	{
		for (j = 0; j < prod; j++)
		{
			if (sol[i][j] > 0)
			{
				sum_c[j] += cost[i][j];
				sum_r[j] += revenue[i][j];
			}
		}
	}
	/*for (j = 0; j < prod; j++)
	{
		if (solp[j]>0)
		{
			sum_c[j] += fcpo[j];
		}
	}*/
	//*****ERRO NO CUSTO
	for(j=0;j<prod;j++)
		if (sum_cost[j] != sum_c[j])
		{
			return false;
		}
	for (j = 0; j < prod; j++)
		if (sum_revenue[j] != sum_r[j])
			return false;
	/*if (total_cost != 0 && total_cost != sum_r - sum_c)
		return false;*/
}
